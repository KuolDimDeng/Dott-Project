// Simplified axios configuration that works in both client and server environments
// Uses dynamic imports for client-only dependencies

import axios from 'axios';
import { appCache } from '../utils/appCache';
import { logger } from '@/utils/logger';
import https from 'https';

// Always use HTTPS for backend connections to avoid redirect issues
const PROTOCOL = 'https';

// Use the current origin as the base URL unless defined
// Ensure the URL always uses HTTPS
const BASE_URL = typeof window !== 'undefined' 
  ? (window.location.protocol === 'https:' 
      ? window.location.origin 
      : window.location.origin.replace('http:', 'https:'))
  : process.env.NEXT_PUBLIC_API_URL || `${PROTOCOL}://127.0.0.1:3000`;
const BACKEND_API_URL = process.env.BACKEND_API_URL || `${PROTOCOL}://127.0.0.1:8000`;

// Create main axios instance for API calls
const axiosInstance = axios.create({
  baseURL: '/api',
  timeout: 30000,
  headers: {
    'Content-Type': 'application/json',
    // Always default to using AWS RDS for data
    'X-Data-Source': 'AWS_RDS',
    'X-Database-Only': 'true'
  },
  // Never follow redirects - fail fast instead to avoid losing auth headers
  maxRedirects: 0
});

// Create server-side axios instance with SSL verification disabled for local development
// This instance is used for direct communication with the backend API
const serverAxiosInstance = axios.create({
  baseURL: BACKEND_API_URL,
  timeout: 30000,
  headers: {
    'Content-Type': 'application/json',
    // Always default to using AWS RDS for data
    'X-Data-Source': 'AWS_RDS',
    'X-Database-Only': 'true'
  },
  httpsAgent: process.env.NODE_ENV !== 'production' ? new https.Agent({
    rejectUnauthorized: false // Disable SSL certificate verification for local development only
  }) : undefined
});

// Create a dedicated backend instance for HR/employee API calls
const backendHrApiInstance = axios.create({
  baseURL: `${BACKEND_API_URL}/api/hr`,
  timeout: 120000, // Increased timeout for HR operations from 90s to 120s
  headers: {
    'Content-Type': 'application/json',
    // Always default to using AWS RDS for data
    'X-Data-Source': 'AWS_RDS',
    'X-Database-Only': 'true',
    // Explicitly include standard CORS headers
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
    'Access-Control-Allow-Headers': 'Origin, X-Requested-With, Content-Type, Accept, Authorization, X-Tenant-ID, X-Business-ID, X-Schema-Name, X-Data-Source, X-Database-Only'
  },
  // Enhanced SSL configuration for local development
  ...(process.env.NODE_ENV !== 'production' ? {
    httpsAgent: new https.Agent({ 
      rejectUnauthorized: false, // Disable SSL verification in development
      requestCert: false,
      secureProtocol: 'TLSv1_2_method'
    }),
    proxy: false // Disable proxy to avoid interference
  } : {}),
  // Add specific settings to improve reliability of connections 
  maxRedirects: 5,
  maxContentLength: 50 * 1024 * 1024, // 50MB
  validateStatus: function (status) {
    // Let 401 and 403 errors be handled by the interceptor
    return (status >= 200 && status < 300) || status === 401 || status === 403;
  },
  // Add automatic retry configuration
  retry: 3,
  retryDelay: 1000,
  // Prevent request abortion on navigation
  cancelToken: undefined,
  signal: undefined,
  // Cookie handling for sessions
  withCredentials: true
});

// AWS RDS-specific configuration for payroll operations
const payrollApiInstance = axios.create({
  baseURL: `${BACKEND_API_URL}/api/payroll`,
  timeout: 60000, // 60 second timeout for payroll operations
  headers: {
    'Content-Type': 'application/json',
    // Always use AWS RDS for payroll data
    'X-Data-Source': 'AWS_RDS',
    'X-Database-Only': 'true',
    'X-Use-Mock-Data': 'false'
  },
  // Add specific settings to improve reliability of connections
  maxRedirects: 3,
  validateStatus: function (status) {
    return (status >= 200 && status < 300) || status === 401 || status === 403;
  },
  // Cookie handling for sessions
  withCredentials: true
});

// Log the configuration for debugging
console.log('[AxiosConfig] Instances configured to use AWS RDS database:', {
  axiosInstance: true,
  serverAxiosInstance: true,
  backendHrApiInstance: true,
  payrollApiInstance: true
});

// Add request interceptor to axiosInstance for AWS RDS DB
axiosInstance.interceptors.request.use(async (config) => {
  try {
    // Initialize headers if not present
    config.headers = config.headers || {};

    // Always ensure we're using AWS RDS
    config.headers['X-Data-Source'] = 'AWS_RDS';
    config.headers['X-Database-Only'] = 'true';
    config.headers['X-Use-Mock-Data'] = 'false';
    
    // Add flag for payroll-specific endpoints
    if (config.url?.includes('/payroll/')) {
      config.headers['X-Payroll-RDS'] = 'true';
    }

    return config;
  } catch (error) {
    logger.error('[AxiosConfig] Error in AWS RDS request interceptor:', error);
    return config;
  }
});

// Apply the same interceptor to server instance
serverAxiosInstance.interceptors.request.use(async (config) => {
  try {
    // Initialize headers if not present
    config.headers = config.headers || {};

    // Always ensure we're using AWS RDS
    config.headers['X-Data-Source'] = 'AWS_RDS';
    config.headers['X-Database-Only'] = 'true';
    config.headers['X-Use-Mock-Data'] = 'false';
    
    return config;
  } catch (error) {
    logger.error('[AxiosConfig] Error in AWS RDS request interceptor:', error);
    return config;
  }
});

// Add request interceptor to backendHrApiInstance for authentication and circuit breaking
backendHrApiInstance.interceptors.request.use(async (config) => {
  try {
    // Get tenant ID from APP_CACHE if available
    let tenantId = null;
    if (typeof window !== 'undefined' && appCache.getAll()) {
      tenantId = (appCache && appCache.get('tenant.id'));
      logger.debug(`[AxiosConfig] Using tenant ID from APP_CACHE for HR API: ${tenantId}`);
    } else {
      // Try to get tenant ID from Cognito if needed
      try {
        const { getTenantId } = await import('@/utils/tenantUtils');
        tenantId = await getTenantId();
      } catch (e) {
        logger.warn('[AxiosConfig] Could not load tenant ID:', e?.message);
      }
    }
    
    // Initialize headers if not present
    config.headers = config.headers || {};
    
    // Standardize tenant headers - use only backend-expected format
    if (tenantId) {
      // Only include the standard tenant header format to avoid CORS issues
      config.headers['X-Tenant-ID'] = tenantId;
      
      // Add tenant ID as query parameter as fallback
      if (!config.params) config.params = {};
      config.params.tenantId = tenantId;
    }
    
    // Ensure we're using AWS RDS
    config.headers['X-Data-Source'] = 'AWS_RDS';
    config.headers['X-Database-Only'] = 'true';
    config.headers['X-Use-Mock-Data'] = 'false';
    
    // Get auth token from APP_CACHE if available
    if (typeof window !== 'undefined' && appCache.getAll()
      const token = (appCache && appCache.get('auth.token'));
      if (token) {
        logger.debug(`[AxiosConfig] Using auth token from APP_CACHE for HR API`);
        config.headers['Authorization'] = `Bearer ${token}`;
      }
    }

    return config;
  } catch (error) {
    logger.error('[AxiosConfig] Error in HR API request interceptor:', error);
    return config;
  }
});

// Add similar interceptor to payroll instance
payrollApiInstance.interceptors.request.use(async (config) => {
  try {
    // Get tenant ID from APP_CACHE if available
    let tenantId = null;
    if (typeof window !== 'undefined' && appCache.getAll()) {
      tenantId = (appCache && appCache.get('tenant.id'));
      logger.debug(`[AxiosConfig] Using tenant ID from APP_CACHE for Payroll API: ${tenantId}`);
    } else {
      // Try to get tenant ID from Cognito if needed
      try {
        const { getTenantId } = await import('@/utils/tenantUtils');
        tenantId = await getTenantId();
      } catch (e) {
        logger.warn('[AxiosConfig] Could not load tenant ID:', e?.message);
      }
    }
    
    // Initialize headers if not present
    config.headers = config.headers || {};
    
    // Standardize tenant headers - use only backend-expected format
    if (tenantId) {
      // Only include the standard tenant header format to avoid CORS issues
      config.headers['X-Tenant-ID'] = tenantId;
      
      // Add tenant ID as query parameter as fallback
      if (!config.params) config.params = {};
      config.params.tenantId = tenantId;
    }
    
    // Ensure we're using AWS RDS
    config.headers['X-Data-Source'] = 'AWS_RDS';
    config.headers['X-Database-Only'] = 'true';
    config.headers['X-Use-Mock-Data'] = 'false';
    
    // Always add payroll specific header
    config.headers['X-Payroll-RDS'] = 'true';
    
    // Get auth token from APP_CACHE if available
    if (typeof window !== 'undefined' && appCache.getAll()
      const token = (appCache && appCache.get('auth.token'));
      if (token) {
        logger.debug(`[AxiosConfig] Using auth token from APP_CACHE for Payroll API`);
        config.headers['Authorization'] = `Bearer ${token}`;
      }
    }

    return config;
  } catch (error) {
    logger.error('[AxiosConfig] Error in Payroll API request interceptor:', error);
    return config;
  }
});

// Circuit breaker implementation to prevent repeated failed requests
const circuitBreakers = {};

// Simple circuit breaker implementation
class CircuitBreaker {
  constructor(name) {
    this.name = name;
    this.state = 'CLOSED'; // CLOSED (normal), OPEN (blocking requests), HALF_OPEN (testing)
    this.failureCount = 0;
    this.successCount = 0;
    this.lastFailureTime = null;
    this.failureThreshold = 5;
    this.successThreshold = 2;
    this.resetTimeout = 30000; // 30 seconds
    this.requestCount = 0;
  }

  canRequest() {
    if (this.state === 'CLOSED') {
      return true;
    }
    
    if (this.state === 'OPEN') {
      const now = Date.now();
      if (this.lastFailureTime && (now - this.lastFailureTime) > this.resetTimeout) {
        // Try again after timeout
        this.state = 'HALF_OPEN';
        logger.info(`[CircuitBreaker] ${this.name} is now HALF_OPEN`);
        return true;
      }
      return false;
    }
    
    // HALF_OPEN - allow limited requests to test if service is back
    return true;
  }

  recordRequest() {
    this.requestCount++;
  }

  recordSuccess() {
    if (this.state === 'HALF_OPEN') {
      this.successCount++;
      if (this.successCount >= this.successThreshold) {
        this.reset();
        logger.info(`[CircuitBreaker] ${this.name} is now CLOSED (service recovered)`);
      }
    }
    // Always reset failure count on success
    this.failureCount = 0;
  }

  recordFailure() {
    this.failureCount++;
    this.lastFailureTime = Date.now();
    
    if (this.state === 'CLOSED' && this.failureCount >= this.failureThreshold) {
      this.state = 'OPEN';
      logger.warn(`[CircuitBreaker] ${this.name} is now OPEN (too many failures)`);
    } else if (this.state === 'HALF_OPEN') {
      this.state = 'OPEN';
      this.successCount = 0;
      logger.warn(`[CircuitBreaker] ${this.name} is now OPEN (failed while testing)`);
    }
  }

  reset() {
    this.state = 'CLOSED';
    this.failureCount = 0;
    this.successCount = 0;
    this.lastFailureTime = null;
  }
}

// Get or create a circuit breaker for an endpoint
const getCircuitBreaker = (endpoint) => {
  if (!endpoint) {
    endpoint = 'default';
  }
  
  if (!circuitBreakers[endpoint]) {
    circuitBreakers[endpoint] = new CircuitBreaker(endpoint);
  }
  
  return circuitBreakers[endpoint];
};

// Define circuit breaker reset function
const resetCircuitBreakers = (endpoint = null) => {
  if (endpoint) {
    // Reset specific endpoint
    const cb = getCircuitBreaker(endpoint);
    cb.reset();
    logger.info(`[CircuitBreaker] Circuit breaker for ${endpoint} has been reset`);
    return true;
  } else {
    // Reset all circuit breakers
    Object.keys(circuitBreakers).forEach(key => {
      circuitBreakers[key].reset();
    });
    logger.info('[CircuitBreaker] All circuit breakers have been reset');
    return true;
  }
};

// Reset the employees endpoint circuit breaker
resetCircuitBreakers('/employees');

// Modify request interceptor to ensure we're only making HTTPS requests
axiosInstance.interceptors.request.use(
  async (config) => {
    try {
      // For absolute URLs, ensure HTTPS
      if (config.url && config.url.startsWith('http:')) {
        config.url = config.url.replace('http:', 'https:');
      }
      
      // Check if we're in a browser environment
      const isBrowser = typeof window !== 'undefined';
      
      if (isBrowser) {
        try {
          // Dynamically import client-side only modules
          const { getTenantId } = await import('@/utils/tenantUtils');
          const { fetchAuthSession } = await import('@/config/amplifyUnified');
          
          // Use AWS AppCache for tenant ID - prioritize this over other sources
          if (appCache.getAll()
            const cachedTenantId = (appCache && appCache.get('tenant.id'));
            config.headers = {
              ...config.headers,
              'X-Tenant-ID': cachedTenantId
            };
            logger.debug('[AxiosConfig] Using tenant ID from APP_CACHE');
          } else {
            // Fall back to utilities function which will try other sources
            const tenantId = await getTenantId();
            if (tenantId) {
              config.headers = {
                ...config.headers,
                'X-Tenant-ID': tenantId
              };
            }
          }
          
          // Use AWS AppCache for auth tokens if available
          if (appCache.getAll()
            config.headers.Authorization = `Bearer ${(appCache && appCache.get('auth.token'))}`;
            logger.debug('[AxiosConfig] Using auth token from APP_CACHE');
          } else {
            // Fall back to Amplify Auth
            try {
              const session = await fetchAuthSession();
              if (session?.tokens?.accessToken) {
                config.headers.Authorization = `Bearer ${session.tokens.accessToken.toString()}`;
              }
            } catch (authError) {
              logger.warn('[AxiosConfig] Auth session error:', authError.message);
            }
          }
        } catch (importError) {
          logger.warn('[AxiosConfig] Import error in request interceptor:', importError.message);
        }
      }
      
      // Circuit breaker pattern
      const url = config.url?.split('?')[0] || '';
      const cb = getCircuitBreaker(url);
      
      if (!cb.canRequest()) {
        logger.warn(`[AxiosConfig] Circuit breaker open for ${url}, rejecting request`);
        return Promise.reject(new Error(`Circuit breaker open for ${url}`));
      }
      
      // Track this request
      cb.recordRequest();
      config._circuitBreakerHandled = true;
      
      return config;
    } catch (error) {
      logger.error('[AxiosConfig] Error in request interceptor:', error.message);
      return config;
    }
  },
  (error) => Promise.reject(error)
);

// Add circuit breaker to response interceptor
axiosInstance.interceptors.response.use(
  (response) => {
    try {
      // Record success in circuit breaker if available
      const url = response.config.url?.split('?')[0] || '';
      const cb = getCircuitBreaker(url);
      
      if (response.config._circuitBreakerHandled) {
        cb.recordSuccess();
      }
    } catch (e) {
      // Don't let circuit breaker errors affect response
      logger.error('[axiosConfig] Error in circuit breaker success handling:', e.message);
    }
    
    return response;
  },
  async (error) => {
    const originalRequest = error.config;
    const isBrowser = typeof window !== 'undefined';
    
    try {
      // Record failure in circuit breaker if available
      if (originalRequest?._circuitBreakerHandled) {
        const url = originalRequest.url?.split('?')[0] || '';
        const cb = getCircuitBreaker(url);
        cb.recordFailure();
      }
    } catch (e) {
      // Don't let circuit breaker errors affect error response
      logger.error('[axiosConfig] Error in circuit breaker failure handling:', e.message);
    }
    
    // If error is 401 Unauthorized and we haven't retried yet and we're in a browser
    if (isBrowser && error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;
      
      try {
        return await refreshTokenAndRetry(originalRequest);
      } catch (refreshError) {
        logger.error('[axiosConfig] Token refresh failed:', refreshError.message);
        
        // Redirect to login on refresh failure (only in browser)
        if (isBrowser) {
          window.location.href = '/login';
        }
        
        return Promise.reject(refreshError);
      }
    }
    
    // Handle ECONNABORTED errors (request timeouts and aborts)
    if (error.code === 'ECONNABORTED' && !originalRequest._abortRetry) {
      logger.warn('[axiosConfig] Request aborted or timed out, retrying...');
      
      // Mark as retry attempt to prevent infinite loops
      originalRequest._abortRetry = true;
      
      // Increase timeout for retry
      originalRequest.timeout = originalRequest.timeout ? originalRequest.timeout * 1.5 : 45000;
      
      // Add a delay before retrying
      return new Promise(resolve => {
        setTimeout(() => {
          resolve(axiosInstance(originalRequest));
        }, 2000);
      });
    }
    
    return Promise.reject(error);
  }
);

// Alias for compatibility with code using useApi
const useApi = axiosInstance;

// Create a server-side safe axios instance that doesn't use client-side utilities
const serverSafeAxiosInstance = axios.create({
  timeout: 15000,
  headers: {
    'Content-Type': 'application/json',
  }
});

// Add SSL handling for development
if (typeof process !== 'undefined' && process.env.NODE_ENV === 'development') {
  const https = require('https');
  serverSafeAxiosInstance.defaults.httpsAgent = new https.Agent({
    rejectUnauthorized: false
  });
}

// Fix proper BACKEND_URL configuration for server-side requests
serverSafeAxiosInstance.interceptors.request.use(
  (config) => {
    // Set a proper base URL for backend API requests
    if (!config.baseURL) {
      // Always use HTTPS to avoid CORS issues
      const backendUrl = process.env.BACKEND_API_URL || 
        process.env.NEXT_PUBLIC_API_URL || 
        'https://127.0.0.1:8000';
      
      if (typeof window === 'undefined' && process.env.NODE_ENV === 'development') {
        console.log(`[ServerAxiosConfig] Using backend URL: ${backendUrl} for request: ${config.url}`);
      }
      
      // Update the config with the correct baseURL
      config.baseURL = backendUrl;
    }
    
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Add simpler interceptors and error handler for connection issues
serverSafeAxiosInstance.interceptors.response.use(
  (response) => response,
  (error) => {
    // Log connection errors in a helpful way
    if (error.code === 'ECONNREFUSED') {
      console.error(`[ServerAxiosConfig] Connection refused to ${error.config?.url || 'unknown URL'}`);
      error.message = `Connection to backend server failed (${error.address}:${error.port})`;
    } else if (error.code === 'ECONNABORTED') {
      console.error(`[ServerAxiosConfig] Connection timeout to ${error.config?.url || 'unknown URL'}`);
      error.message = 'Connection to backend server timed out';
    } else if (error.code === 'EPROTO') {
      console.error(`[ServerAxiosConfig] SSL Protocol error with ${error.config?.url || 'unknown URL'}`);
      error.message = 'SSL Protocol error - possible mismatch between HTTP/HTTPS';
    } else {
      // Handle errors in server components
      console.error('[Server] API request error:', error.message);
    }
    return Promise.reject(error);
  }
);

// Create a backend axios instance specifically for server-to-server communication
const backendAxiosInstance = axios.create({
  baseURL: BACKEND_API_URL,
  timeout: 30000,
  headers: {
    'Content-Type': 'application/json',
  }
});

const enhancedAxiosInstance = axios.create({
  baseURL: BASE_URL,
  timeout: 40000,
  headers: {
    'Content-Type': 'application/json',
  }
});

// Add the same interceptors to the enhanced instance
enhancedAxiosInstance.interceptors.request.use(
  async (config) => {
    try {
      const authSession = await fetchAuthSession();
      if (authSession?.tokens?.accessToken) {
        config.headers['Authorization'] = `Bearer ${authSession.tokens.accessToken.toString()}`;
        config.headers['x-id-token'] = authSession.tokens.accessToken.toString();
        
        if (typeof window !== 'undefined') {
          const tenantId = localStorage.getItem('tenantId');
          if (tenantId) {
            config.headers['x-tenant-id'] = tenantId;
          }
        }
      }
      return config;
    } catch (error) {
      console.warn('Failed to get auth session for enhanced API request', error);
      return config;
    }
  },
  (error) => Promise.reject(error)
);

// Retry a request with exponential backoff
const retryRequest = async (requestFn, maxRetries = 3, delay = 1000) => {
  let lastError;
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      return await requestFn();
    } catch (error) {
      lastError = error;
      // Don't retry on 4xx client errors (except 429 too many requests)
      if (error.response && error.response.status >= 400 && error.response.status < 500 
          && error.response.status !== 429) {
        throw error;
      }
      
      // Last attempt failed, throw
      if (attempt === maxRetries) {
        throw error;
      }
      
      // Calculate delay with exponential backoff
      const backoffDelay = delay * Math.pow(2, attempt);
      
      // Wait before next attempt
      await new Promise(resolve => setTimeout(resolve, backoffDelay));
    }
  }
  throw lastError;
};

// Test functions
const testStandardTimeout = async (url, timeout) => {
  return axiosInstance.get(url, { timeout });
};

const testEnhancedTimeout = async (url, timeout) => {
  return enhancedAxiosInstance.get(url, { timeout });
};

const testRetryMechanism = async (url, timeout, maxRetries) => {
  const config = { url, method: 'get', timeout, maxRetries };
  return retryRequest(config);
};

// Debug function
const initAxiosDebug = () => {
  if (typeof window !== 'undefined') {
    window._axiosDebug = {
      axiosInstance,
      enhancedAxiosInstance,
      serverAxiosInstance,
      serverSafeAxiosInstance,
      backendAxiosInstance,
      retryRequest,
      testStandardTimeout,
      testEnhancedTimeout,
      testRetryMechanism
    };
  }
};

// Connection diagnostics
const diagnoseConnection = async (targetUrl = `${BACKEND_API_URL}/api/hr/employees`) => {
  logger.info(`[AxiosConfig] Diagnosing connection to: ${targetUrl}`);
  try {
    const results = {
      url: targetUrl,
      timestamp: new Date().toISOString(),
      tests: {}
    };
    
    // Test 1: Basic connection
    try {
      const startTime = Date.now();
      const response = await axios.get(targetUrl, { 
        timeout: 5000,
        validateStatus: () => true // Accept any status
      });
      const endTime = Date.now();
      
      results.tests.basic = {
        success: response.status < 500,
        status: response.status,
        statusText: response.statusText,
        responseTime: endTime - startTime,
        hasData: !!response.data
      };
    } catch (error) {
      results.tests.basic = {
        success: false,
        error: error.message,
        code: error.code
      };
    }
    
    // Test 2: With credentials
    try {
      const startTime = Date.now();
      const response = await axios.get(targetUrl, { 
        timeout: 5000,
        validateStatus: () => true,
        withCredentials: true
      });
      const endTime = Date.now();
      
      results.tests.withCredentials = {
        success: response.status < 500,
        status: response.status,
        statusText: response.statusText,
        responseTime: endTime - startTime
      };
    } catch (error) {
      results.tests.withCredentials = {
        success: false,
        error: error.message,
        code: error.code
      };
    }
    
    // Test 3: Using backendHrApiInstance
    try {
      const startTime = Date.now();
      // Strip the base URL part from the target URL for this test
      const endpoint = targetUrl.replace(`${BACKEND_API_URL}/hr`, '');
      const response = await backendHrApiInstance.get(endpoint || '/', { 
        timeout: 5000,
        validateStatus: () => true
      });
      const endTime = Date.now();
      
      results.tests.backendHrApiInstance = {
        success: response.status < 500,
        status: response.status,
        statusText: response.statusText,
        responseTime: endTime - startTime
      };
    } catch (error) {
      results.tests.backendHrApiInstance = {
        success: false,
        error: error.message,
        code: error.code
      };
    }
    
    logger.info('[Diagnostics] Connection test results:', results);
    return results;
  } catch (error) {
    logger.error('[AxiosConfig] Connection diagnostic error:', error);
    return {
      success: false,
      status: error.response?.status || 0,
      message: `Connection diagnostic failed: ${error.message}`,
      error: error.toString()
    };
  }
};

// Connection verification function
const verifyBackendConnection = async () => {
  const healthEndpoint = `${BACKEND_API_URL}/api/hr/health`;
  logger.info(`[BackendConnectionCheck] Verifying backend connection to: ${healthEndpoint}`);
  
  // First reset ALL circuit breakers
  resetCircuitBreakers();
  logger.info('[BackendConnectionCheck] All circuit breakers have been reset');
  
  try {
    // Get tenant ID from APP_CACHE or Cognito
    let tenantId = null;
    if (typeof window !== 'undefined') {
      if (appCache.getAll()
        tenantId = (appCache && appCache.get('tenant.id'));
        logger.debug(`[BackendConnectionCheck] Using tenant ID from APP_CACHE: ${tenantId}`);
      } else {
        try {
          // Try to get tenant ID from Cognito
          const { getTenantIdFromCognito } = await import('@/utils/tenantUtils');
          tenantId = await getTenantIdFromCognito();
          logger.debug(`[BackendConnectionCheck] Using tenant ID from Cognito: ${tenantId}`);
        } catch (error) {
          logger.warn('[BackendConnectionCheck] Could not get tenant ID from Cognito:', 
            error?.message || 'Unknown error');
        }
      }
    }
    
    // First try a basic GET request without headers to avoid CORS preflight
    try {
      logger.info('[BackendConnectionCheck] Trying health check without headers first...');
      const basicResponse = await axios.get(healthEndpoint, {
        timeout: 5000,
        validateStatus: () => true,
        // Disable certificate verification in development
        ...(process.env.NODE_ENV !== 'production' && {
          httpsAgent: new https.Agent({ rejectUnauthorized: false })
        })
      });
      
      // If successful, return the result
      if (basicResponse.status >= 200 && basicResponse.status < 300) {
        const responseTime = 0; // Not measuring time for simplicity
        logger.info(`[BackendConnectionCheck] Connection successful without tenant header:`, basicResponse.data);
        
        return {
          success: true,
          status: basicResponse.status,
          message: "Connection successful",
          responseTime,
          data: basicResponse.data
        };
      }
      
      // If 403, we need to try with tenant ID
      logger.info(`[BackendConnectionCheck] Basic health check returned ${basicResponse.status}, trying with tenant ID...`);
    } catch (basicError) {
      // Provide detailed error information for the basic request
      const basicErrorDetails = {
        message: basicError?.message || 'Unknown error',
        code: basicError?.code || 'UNKNOWN',
        isAxiosError: basicError?.isAxiosError || false,
        status: basicError?.response?.status || 0,
        statusText: basicError?.response?.statusText || '',
        url: healthEndpoint
      };
      
      logger.warn('[BackendConnectionCheck] Basic health check failed:', basicErrorDetails);
    }
    
    // Now try with tenant ID
    const startTime = Date.now();
    
    // Create custom axios instance for this request to avoid CORS issues
    const customAxios = axios.create({
      timeout: 5000,
      validateStatus: () => true,
      ...(process.env.NODE_ENV !== 'production' && {
        httpsAgent: new https.Agent({ rejectUnauthorized: false })
      })
    });
    
    // Start with a preflight request
    logger.info('[BackendConnectionCheck] Sending OPTIONS preflight request...');
    try {
      await customAxios.options(healthEndpoint);
      logger.info('[BackendConnectionCheck] Preflight request successful');
    } catch (preflightError) {
      // Provide detailed error for preflight
      const preflightErrorDetails = {
        message: preflightError?.message || 'Unknown preflight error',
        code: preflightError?.code || 'PREFLIGHT_ERROR',
        method: 'OPTIONS'
      };
      
      logger.warn('[BackendConnectionCheck] Preflight error (continuing anyway):', preflightErrorDetails);
    }
    
    // Create headers with tenant ID
    const headers = {};
    if (tenantId) {
      headers['X-Tenant-ID'] = tenantId;
    }
    
    // Use the custom axios instance for the actual request
    const response = await customAxios.get(healthEndpoint, {
      headers: headers
    });
    
    const responseTime = Date.now() - startTime;
    const isSuccess = response.status >= 200 && response.status < 300;
    
    if (isSuccess) {
      logger.info(`[BackendConnectionCheck] Connection successful (${responseTime}ms):`, response.data);
    } else {
      logger.warn(`[BackendConnectionCheck] Connection returned non-success status ${response.status} (${responseTime}ms):`, response.data);
    }
    
    return {
      success: isSuccess,
      status: response.status,
      message: isSuccess ? "Connection successful" : `Received status code ${response.status}`,
      responseTime,
      data: response.data
    };
  } catch (error) {
    // Enhanced error details with safe access to properties
    const errorDetails = {
      message: error?.message || 'Unknown error',
      code: error?.code || 'ERROR',
      isAxiosError: error?.isAxiosError || false,
      status: error?.response?.status || 0,
      statusText: error?.response?.statusText || '',
      url: healthEndpoint,
      timestamp: new Date().toISOString()
    };
    
    // For network errors, provide additional diagnostic info
    if (error?.code === 'ECONNREFUSED' || error?.code === 'ECONNABORTED' || error?.message?.includes('timeout')) {
      errorDetails.diagnosticInfo = {
        backendUrl: BACKEND_API_URL,
        networkAvailable: typeof navigator !== 'undefined' && navigator.onLine,
        sslEnabled: BACKEND_API_URL.startsWith('https'),
        port: new URL(BACKEND_API_URL).port || (BACKEND_API_URL.startsWith('https') ? '443' : '80')
      };
    }
    
    logger.error('[BackendConnectionCheck] Connection failed:', errorDetails);
    
    // Try a fallback method for connection check
    try {
      logger.info('[BackendConnectionCheck] Attempting fallback connection check...');
      const fallbackResponse = await fetch(healthEndpoint, { 
        method: 'GET',
        mode: 'cors',
        cache: 'no-cache',
        credentials: 'omit',
        headers: { 'Accept': 'application/json' },
        redirect: 'follow',
        timeout: 3000,
        signal: AbortSignal.timeout(3000) // 3 second timeout
      });
      
      if (fallbackResponse.ok) {
        logger.info('[BackendConnectionCheck] Fallback connection check successful');
        const fallbackData = await fallbackResponse.text();
        
        return {
          success: true,
          status: fallbackResponse.status,
          message: 'Connection successful via fallback method',
          fallbackData
        };
      } else {
        logger.warn(`[BackendConnectionCheck] Fallback check failed with status: ${fallbackResponse.status}`);
      }
    } catch (fallbackError) {
      logger.warn('[BackendConnectionCheck] Fallback connection check also failed:', 
        fallbackError?.message || 'Unknown error');
    }
    
    return {
      success: false,
      status: errorDetails.status || 0,
      message: `Connection failed: ${errorDetails.message}`,
      errorDetails,
      error: error?.toString() || 'Unknown error',
      timestamp: new Date().toISOString()
    };
  }
};

// Add the function after the verifyBackendConnection function
const diagnoseAndFixBackendConnection = async () => {
  logger.info('[BackendConnectionCheck] Diagnosing and attempting to fix connection issues');
  
  // First reset all circuit breakers
  resetCircuitBreakers();
  logger.info('[BackendConnectionCheck] All circuit breakers have been reset');
  
  // Try to get tenant ID
  let tenantId = null;
  try {
    if (typeof window !== 'undefined') {
      // Use APP_CACHE if available
      if (appCache.getAll()
        tenantId = (appCache && appCache.get('tenant.id'));
      } else {
        // Try to dynamically import and use tenantUtils
        const { getTenantId } = await import('@/utils/tenantUtils');
        tenantId = await getTenantId();
      }
      
      if (tenantId) {
        logger.info(`[BackendConnectionCheck] Found tenant ID: ${tenantId}`);
      } else {
        logger.warn('[BackendConnectionCheck] No tenant ID found');
      }
    }
  } catch (error) {
    logger.error('[BackendConnectionCheck] Error getting tenant ID:', error);
  }
  
  // Test connection with backendHrApiInstance
  try {
    const headers = tenantId ? { 'X-Tenant-ID': tenantId } : {};
    const response = await backendHrApiInstance.get('/health', {
      timeout: 10000,
      validateStatus: () => true,
      headers
    });
    
    logger.info(`[BackendConnectionCheck] Health check status: ${response.status}`, response.data);
    
    if (response.status === 200) {
      logger.info('[BackendConnectionCheck] Backend connection restored successfully');
      return {
        success: true,
        message: 'Connection restored successfully',
        status: response.status,
        data: response.data
      };
    } else if (response.status === 403 && tenantId) {
      logger.warn('[BackendConnectionCheck] Received 403 despite having tenant ID');
      return {
        success: false,
        message: 'Authentication issues with backend',
        status: response.status,
        data: response.data
      };
    } else {
      return {
        success: false,
        message: `Health check failed with status ${response.status}`,
        status: response.status,
        data: response.data
      };
    }
  } catch (error) {
    logger.error('[BackendConnectionCheck] Health check failed:', error);
    return {
      success: false,
      message: `Connection error: ${error.message}`,
      error: error.toString()
    };
  }
};

// At the end of the file, before the closing if statement for window.__diagnostics
// Add a function to force reset the whole connection system
const resetConnectionSystem = async () => {
  logger.info('[ConnectionReset] Resetting all connection systems');
  
  try {
    // Reset all circuit breakers
    resetCircuitBreakers();
    logger.info('[ConnectionReset] All circuit breakers have been reset');
    
    // Clear any cached connection errors
    if (typeof window !== 'undefined') {
      if (appCache.getAll()) {
        delete appCache.getAll().connectionErrors;
        logger.info('[ConnectionReset] Cleared cached connection errors');
      }
    }
    
    // Try a basic connection with no tenant ID
    const healthEndpoint = `${BACKEND_API_URL}/api/hr/health`;
    logger.info(`[ConnectionReset] Testing basic connection to: ${healthEndpoint}`);
    
    try {
      const response = await axios.get(healthEndpoint, { 
        timeout: 3000,
        validateStatus: () => true,
        ...(process.env.NODE_ENV !== 'production' && {
          httpsAgent: new https.Agent({ rejectUnauthorized: false })
        })
      });
      
      logger.info(`[ConnectionReset] Basic connection test result: ${response.status}`, response.data);
    } catch (error) {
      logger.error('[ConnectionReset] Basic connection test failed:', error.message);
    }
    
    return {
      success: true,
      message: 'Connection system reset completed',
      timestamp: new Date().toISOString()
    };
  } catch (error) {
    logger.error('[ConnectionReset] Error during reset:', error);
    return {
      success: false,
      message: `Reset failed: ${error.message}`,
      error: error.toString()
    };
  }
};

// If in development, expose diagnostics to window for easier debugging
if (typeof window !== 'undefined' && process.env.NODE_ENV === 'development') {
  window.__diagnostics = {
    diagnoseConnection,
    resetCircuitBreakers,
    circuitBreakers,
    verifyBackendConnection,
    diagnoseAndFixBackendConnection,
    resetConnectionSystem
  };
}

// Export the circuit breaker utilities and axios instances
export {
  axiosInstance,
  useApi,
  backendHrApiInstance,
  serverAxiosInstance,
  serverSafeAxiosInstance,
  backendAxiosInstance,
  enhancedAxiosInstance,
  resetCircuitBreakers,
  verifyBackendConnection,
  diagnoseConnection,
  diagnoseAndFixBackendConnection,
  resetConnectionSystem,
  retryRequest
};

// Default export for backwards compatibility
export default axiosInstance; 