import { appCache } from '../utils/appCache';
import { fetchAuthSession  } from '@/config/amplifyUnified';
import { appCache } from '../utils/appCache';
import { logger } from './logger';
import { appCache } from '../utils/appCache';
import { logMemoryUsage, trackMemory, detectMemorySpike } from '@/utils/memoryDebug';

/**
 * Robust function to mark onboarding as complete in Cognito
 * Uses multiple approaches to ensure the attribute is set correctly:
 * 1. Direct Amplify updateUserAttributes call
 * 2. Server-side API call as backup
 * 3. Admin API call as last resort
 * 
 * @returns {Promise<boolean>} True if successful
 */
export async function completeOnboarding() {
  // Generate a request ID for tracking this operation
  const requestId = Math.random().toString(36).substring(2, 15);
  let success = false;
  
  logger.info(`[completeOnboarding:${requestId}] Starting onboarding completion process`);
  
  // Define the user attributes we want to set - IMPORTANT: Use lowercase 'complete' consistently
  const userAttributes = {
    'custom:onboarding': 'complete', // Lowercase for consistency
    'custom:setupdone': 'true',      // Lowercase 'true' for consistency
    'custom:updated_at': new Date().toISOString(),
    'custom:onboardingCompletedAt': new Date().toISOString()
  };
  
  // Store in app cache
  try {
    // Initialize app cache if needed
    if (typeof window !== 'undefined') {
      // Initialize app cache if needed
      if (!appCache.getAll()) {
        appCache.init();
      }
      if (!appCache.get('onboarding')) {
        appCache.set('onboarding', {});
      }
      
      // Store in app cache
      appCache.set('onboarding.status', 'complete');
      appCache.set('onboarding.setupDone', true);
      appCache.set('onboarding.completedAt', new Date().toISOString());
      appCache.set('onboarding.lastUpdated', new Date().toISOString());
    }
  } catch (storageError) {
    logger.warn(`[completeOnboarding:${requestId}] Failed to set app cache:`, storageError.message);
  }

  // Attempt 1: Direct Amplify call
  try {
    logger.debug(`[completeOnboarding:${requestId}] Attempting direct Amplify update`);
    
    // Dynamically import to avoid SSR issues
    const { updateUserAttributes } = await import('@/config/amplifyUnified');
    
    // Make the API call
    await updateUserAttributes({ userAttributes });
    
    logger.info(`[completeOnboarding:${requestId}] Successfully updated via Amplify direct call`);
    success = true;
    
    // Verify the update worked
    try {
      const session = await fetchAuthSession();
      const userInfo = session?.tokens?.idToken?.payload;
      const onboardingStatus = userInfo?.['custom:onboarding']?.toLowerCase();
      
      if (onboardingStatus === 'complete') {
        logger.info(`[completeOnboarding:${requestId}] Verified onboarding is now complete`);
      } else {
        logger.warn(`[completeOnboarding:${requestId}] Attribute update succeeded but verification shows onboarding status is still: ${onboardingStatus}`);
        // Continue to fallback methods
        success = false;
      }
    } catch (verifyError) {
      logger.warn(`[completeOnboarding:${requestId}] Could not verify attribute update:`, verifyError.message);
    }
  } catch (error) {
    logger.warn(`[completeOnboarding:${requestId}] Direct Amplify update failed:`, error.message);
  }

  // Attempt 2: API call with explicit token
  if (!success) {
    try {
      logger.debug(`[completeOnboarding:${requestId}] Attempting API update with token`);
      
      // Get the current session for tokens
      const session = await fetchAuthSession();
      const accessToken = session?.tokens?.accessToken?.toString();
      
      if (!accessToken) {
        throw new Error('No access token available');
      }
      
      // Make API call with our token
      const response = await fetch('/api/user/update-attributes', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${accessToken}`,
          'X-Request-ID': requestId
        },
        body: JSON.stringify({
          attributes: userAttributes,
          forceUpdate: true
        })
      });
      
      if (!response.ok) {
        throw new Error(`API call failed with status: ${response.status}`);
      }
      
      const result = await response.json();
      logger.info(`[completeOnboarding:${requestId}] API update successful:`, result);
      success = true;
      
      // Double-check with a fresh session
      try {
        // Clear any cached sessions first
        await fetchAuthSession({ forceRefresh: true });
        const freshSession = await fetchAuthSession();
        const freshUserInfo = freshSession?.tokens?.idToken?.payload;
        const freshOnboardingStatus = freshUserInfo?.['custom:onboarding']?.toLowerCase();
        
        if (freshOnboardingStatus === 'complete') {
          logger.info(`[completeOnboarding:${requestId}] Verified onboarding is complete with fresh session`);
        } else {
          logger.warn(`[completeOnboarding:${requestId}] Attribute still not updated after API call. Status: ${freshOnboardingStatus}`);
          success = false;
        }
      } catch (freshVerifyError) {
        logger.warn(`[completeOnboarding:${requestId}] Could not verify with fresh session:`, freshVerifyError.message);
      }
    } catch (apiError) {
      logger.warn(`[completeOnboarding:${requestId}] API update failed:`, apiError.message);
    }
  }

  // Attempt 3: Admin API endpoint
  if (!success) {
    try {
      logger.debug(`[completeOnboarding:${requestId}] Attempting admin API endpoint`);
      
      // Call our special onboarding complete endpoint
      const response = await fetch('/api/onboarding/setup/complete', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Force-Update': 'true',
          'X-Request-ID': requestId
        },
        body: JSON.stringify({
          forceComplete: true,
          attributes: userAttributes
        })
      });
      
      if (!response.ok) {
        throw new Error(`Admin API failed with status: ${response.status}`);
      }
      
      const result = await response.json();
      logger.info(`[completeOnboarding:${requestId}] Admin API successful:`, result);
      success = true;
    } catch (adminError) {
      logger.error(`[completeOnboarding:${requestId}] Admin API failed:`, adminError.message);
      
      // Try the backup API endpoint
      try {
        const backupResponse = await fetch('/api/onboarding/complete', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Request-ID': requestId
          },
          body: JSON.stringify({
            attributes: userAttributes
          })
        });
        
        if (!backupResponse.ok) {
          throw new Error(`Backup API failed with status: ${backupResponse.status}`);
        }
        
        const backupResult = await backupResponse.json();
        logger.info(`[completeOnboarding:${requestId}] Backup API successful:`, backupResult);
        success = true;
      } catch (backupError) {
        logger.error(`[completeOnboarding:${requestId}] All onboarding update methods failed:`, backupError.message);
      }
    }
  }

  // Attempt 4 (last resort): Check if we're already complete
  if (!success) {
    try {
      const session = await fetchAuthSession();
      const userInfo = session?.tokens?.idToken?.payload;
      const onboardingStatus = userInfo?.['custom:onboarding']?.toLowerCase();
      
      if (onboardingStatus === 'complete') {
        logger.info(`[completeOnboarding:${requestId}] Found onboarding already complete despite update failures`);
        success = true;
      }
    } catch (checkError) {
      logger.error(`[completeOnboarding:${requestId}] Final verification check failed:`, checkError.message);
    }
  }

  logger.info(`[completeOnboarding:${requestId}] Process completed with success=${success}`);
  return success;
}