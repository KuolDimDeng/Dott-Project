/**
 * AWS Amplify Resiliency Utilities
 * 
 * Provides enhanced error handling and retries for AWS Amplify operations
 */

import { logger } from './logger';
import { 
  trackCognitoFailure, 
  trackCognitoSuccess, 
  isCognitoUnreliable, 
  getCognitoTimeout, 
  resetCognitoFailures, 
  shouldAttemptCognitoRequest 
} from './networkMonitor';
import { getFallbackTenantId } from './tenantFallback';
import { updateUserAttributes } from '@/config/amplifyUnified';

// Cached values for fallback
const cachedValues = {
  userAttributes: null,
  tokens: null,
  timestamp: 0,
  session: null
};

// Cache user attributes if available
export const cacheUserAttributes = (attributes) => {
  if (attributes && Object.keys(attributes).length > 0) {
    cachedValues.userAttributes = { ...attributes };
    cachedValues.timestamp = Date.now();
    return true;
  }
  return false;
};

// Cache tokens for later use
export const cacheTokens = (tokens) => {
  if (tokens) {
    cachedValues.tokens = tokens;
    cachedValues.timestamp = Date.now();
    return true;
  }
  return false;
};

// Cache session data
export const cacheSession = (session) => {
  if (session) {
    cachedValues.session = session;
    cachedValues.timestamp = Date.now();
    return true;
  }
  return false;
};

/**
 * Resilient wrapper for fetchUserAttributes
 * Includes timeouts, retries, and fallbacks to cached data
 * 
 * @param {Function} fetchUserAttributesFn - The Amplify fetchUserAttributes function to call
 * @param {Object} options - Options for the request
 * @returns {Promise<Object>} User attributes or cached fallback
 */
export const resilientFetchUserAttributes = async (fetchUserAttributesFn, options = {}) => {
  // Check circuit breaker state before attempting request
  if (!shouldAttemptCognitoRequest()) {
    logger.warn('[AmplifyResiliency] Circuit breaker is OPEN, using cached attributes');
    
    // Use cached attributes if available
    if (fallbackToCache && cachedValues.userAttributes) {
      const age = Date.now() - cachedValues.timestamp;
      logger.info(`[AmplifyResiliency] Using cached user attributes (${age / 1000}s old)`);
      return cachedValues.userAttributes;
    }
    
    // Try fallback tenant ID if no cached attributes
    const tenantId = getFallbackTenantId();
    if (tenantId) {
      logger.info('[AmplifyResiliency] Using emergency fallback user attributes with tenant ID:', tenantId);
      return {
        'custom:tenant_ID': tenantId,
        'custom:tenantId': tenantId
      };
    }
    
    throw new Error('Circuit breaker is open and no fallback data available');
  }
  // Check circuit breaker state before attempting request
  if (!shouldAttemptCognitoRequest()) {
    logger.warn('[AmplifyResiliency] Circuit breaker is OPEN, using cached attributes');
    
    // Use cached attributes if available
    if (fallbackToCache && cachedValues.userAttributes) {
      const age = Date.now() - cachedValues.timestamp;
      logger.info(`[AmplifyResiliency] Using cached user attributes (${age / 1000}s old)`);
      return cachedValues.userAttributes;
    }
    
    // Try fallback tenant ID if no cached attributes
    const tenantId = getFallbackTenantId();
    if (tenantId) {
      logger.info('[AmplifyResiliency] Using emergency fallback user attributes with tenant ID:', tenantId);
      return {
        'custom:tenant_ID': tenantId,
        'custom:tenantId': tenantId
      };
    }
    
    throw new Error('Circuit breaker is open and no fallback data available');
  }
  const {
    maxRetries = 2,
    timeoutOverride,
    fallbackToCache = true
  } = options;
  
  // Get recommended timeout
  const timeout = timeoutOverride || getCognitoTimeout();
  let attempts = 0;
  let lastError = null;
  
  // Get the AbortController for the timeout
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeout);
  
  try {
    // First try with normal timeout
    while (attempts <= maxRetries) {
      try {
        logger.debug(`[AmplifyResiliency] Attempting to fetch user attributes (attempt ${attempts + 1}/${maxRetries + 1})`);
        
        // Create a timeout for this specific attempt
        const startTime = Date.now();
        
        // Call the actual Amplify function with the signal
        const attributes = await fetchUserAttributesFn();
        
        // If successful, clear timeout and cache the result
        clearTimeout(timeoutId);
        const duration = Date.now() - startTime;
        
        // Log performance info
        logger.debug(`[AmplifyResiliency] Successfully fetched user attributes in ${duration}ms`);
        
        // Track success for circuit breaker
        trackCognitoSuccess();
        
        // Track success for circuit breaker
        trackCognitoSuccess();
        
        // Cache for potential future fallback
        cacheUserAttributes(attributes);
        
        // If we had previous failures but now succeeded, reset failure count
        if (attempts > 0) {
          resetCognitoFailures();
        }
        
        return attributes;
      } catch (error) {
        attempts++;
        lastError = error;
        
        // Handle different error types
        if (error.name === 'TimeoutError' || error.name === 'AbortError') {
          logger.warn(`[AmplifyResiliency] Timeout fetching user attributes (attempt ${attempts}/${maxRetries + 1})`);
        } else if (error.name === 'NetworkError') {
          logger.warn(`[AmplifyResiliency] Network error fetching user attributes (attempt ${attempts}/${maxRetries + 1}):`, error);
        } else {
          // Other errors (auth errors, etc.)
          logger.warn(`[AmplifyResiliency] Error fetching user attributes (attempt ${attempts}/${maxRetries + 1}):`, error);
          
          // For auth errors, don't retry
          if (error.name === 'NotAuthorizedException' || error.name === 'UserNotFoundException') {
            break;
          }
        }
        
        // Track this failure for future reference
        trackCognitoFailure(error);
        
        // If we've exceeded max retries, break out
        if (attempts > maxRetries) {
          break;
        }
        
        // Wait before retrying with exponential backoff
        const delay = Math.min(2 ** attempts * 500, 3000); // Max 3-second delay
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
    
    // If we couldn't get the attributes after retries, try fallbacks
    if (fallbackToCache && cachedValues.userAttributes) {
      const age = Date.now() - cachedValues.timestamp;
      logger.info(`[AmplifyResiliency] Using cached user attributes (${age / 1000}s old)`);
      return cachedValues.userAttributes;
    }
    
    // Final fallback - try to create minimal user attributes with tenant ID
    const tenantId = getFallbackTenantId();
    if (tenantId) {
      logger.info('[AmplifyResiliency] Using emergency fallback user attributes with tenant ID:', tenantId);
      return {
        'custom:tenant_ID': tenantId,
        'custom:tenantId': tenantId
      };
    }
    
    // Re-throw the last error if all fallbacks fail
    throw lastError;
  } finally {
    clearTimeout(timeoutId);
  }
};

/**
 * Resilient wrapper for getCurrentUser
 * Includes timeouts, retries, and fallbacks
 * 
 * @param {Function} getCurrentUserFn - The Amplify getCurrentUser function to call
 * @param {Object} options - Options for the request
 * @returns {Promise<Object>} User info or fallback
 */
export const resilientGetCurrentUser = async (getCurrentUserFn, options = {}) => {
  // Check circuit breaker state before attempting request
  if (!shouldAttemptCognitoRequest()) {
    logger.warn('[AmplifyResiliency] Circuit breaker is OPEN, skipping getCurrentUser request');
    throw new Error('Circuit breaker is open, request blocked to prevent cascading failures');
  }
  // Check circuit breaker state before attempting request
  if (!shouldAttemptCognitoRequest()) {
    logger.warn('[AmplifyResiliency] Circuit breaker is OPEN, skipping getCurrentUser request');
    throw new Error('Circuit breaker is open, request blocked to prevent cascading failures');
  }
  const {
    maxRetries = 1,
    timeoutOverride,
    fallbackToCache = true
  } = options;
  
  // Get recommended timeout
  const timeout = timeoutOverride || getCognitoTimeout();
  let attempts = 0;
  let lastError = null;
  
  try {
    // First try with normal timeout
    while (attempts <= maxRetries) {
      try {
        logger.debug(`[AmplifyResiliency] Attempting to get current user (attempt ${attempts + 1}/${maxRetries + 1})`);
        
        // Create a timeout for this specific attempt
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeout);
        const startTime = Date.now();
        
        try {
          // Call the actual Amplify function
          const user = await getCurrentUserFn();
          
          // If successful, clear timeout
          clearTimeout(timeoutId);
          const duration = Date.now() - startTime;
          
          // Log performance info
          logger.debug(`[AmplifyResiliency] Successfully got current user in ${duration}ms`);
          
          // Track success for circuit breaker
          trackCognitoSuccess();
          
          // Track success for circuit breaker
          trackCognitoSuccess();
          
          return user;
        } catch (error) {
          clearTimeout(timeoutId);
          throw error;
        }
      } catch (error) {
        attempts++;
        lastError = error;
        
        // Handle different error types
        if (error.name === 'TimeoutError' || error.name === 'AbortError') {
          logger.warn(`[AmplifyResiliency] Timeout getting current user (attempt ${attempts}/${maxRetries + 1})`);
        } else if (error.name === 'NetworkError') {
          logger.warn(`[AmplifyResiliency] Network error getting current user (attempt ${attempts}/${maxRetries + 1}):`, error);
        } else {
          // Other errors (auth errors, etc.)
          logger.warn(`[AmplifyResiliency] Error getting current user (attempt ${attempts}/${maxRetries + 1}):`, error);
          
          // For auth errors, don't retry
          if (error.name === 'NotAuthorizedException' || error.name === 'UserNotFoundException') {
            break;
          }
        }
        
        // Track this failure for future reference
        trackCognitoFailure(error);
        
        // If we've exceeded max retries, break out
        if (attempts > maxRetries) {
          break;
        }
        
        // Wait before retrying with exponential backoff
        const delay = Math.min(2 ** attempts * 500, 2000); // Max 2-second delay
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
    
    // If all retries failed, throw the last error
    throw lastError;
  } catch (error) {
    logger.error('[AmplifyResiliency] All attempts to get current user failed:', error);
    throw error;
  }
};

/**
 * Resilient wrapper for fetchAuthSession
 * Includes timeouts, retries, and fallbacks to cached data
 * 
 * @param {Function} fetchAuthSessionFn - The Amplify fetchAuthSession function to call
 * @param {Object} options - Options for the request
 * @returns {Promise<Object>} Auth session or cached fallback
 */
export const resilientFetchAuthSession = async (fetchAuthSessionFn, options = {}) => {
  // Check circuit breaker state before attempting request
  if (!shouldAttemptCognitoRequest()) {
    logger.warn('[AmplifyResiliency] Circuit breaker is OPEN, using cached session if available');
    
    // Return cached session if available
    if (cachedValues.session) {
      const age = Date.now() - cachedValues.timestamp;
      logger.info(`[AmplifyResiliency] Using cached session (${age / 1000}s old)`);
      return cachedValues.session;
    }
    
    throw new Error('Circuit breaker is open and no cached session available');
  }
  // Check circuit breaker state before attempting request
  if (!shouldAttemptCognitoRequest()) {
    logger.warn('[AmplifyResiliency] Circuit breaker is OPEN, using cached session if available');
    
    // Return cached session if available
    if (cachedValues.session) {
      const age = Date.now() - cachedValues.timestamp;
      logger.info(`[AmplifyResiliency] Using cached session (${age / 1000}s old)`);
      return cachedValues.session;
    }
    
    throw new Error('Circuit breaker is open and no cached session available');
  }
  const {
    maxRetries = 1,
    timeoutOverride,
    fallbackToCache = true,
    forceRefresh = false
  } = options;
  
  // Get recommended timeout
  const timeout = timeoutOverride || getCognitoTimeout();
  let attempts = 0;
  let lastError = null;
  
  try {
    // First try with normal timeout
    while (attempts <= maxRetries) {
      try {
        logger.debug(`[AmplifyResiliency] Attempting to fetch auth session (attempt ${attempts + 1}/${maxRetries + 1})`);
        
        // Create a timeout for this specific attempt
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeout);
        const startTime = Date.now();
        
        try {
          // Call the actual Amplify function
          const session = await fetchAuthSessionFn({ forceRefresh });
          
          // If successful, clear timeout
          clearTimeout(timeoutId);
          const duration = Date.now() - startTime;
          
          // Log performance info
          logger.debug(`[AmplifyResiliency] Successfully fetched auth session in ${duration}ms`);
          
          // Cache for potential future fallback
          cacheSession(session);
          
          return session;
        } catch (error) {
          clearTimeout(timeoutId);
          throw error;
        }
      } catch (error) {
        attempts++;
        lastError = error;
        
        // Handle different error types
        if (error.name === 'TimeoutError' || error.name === 'AbortError') {
          logger.warn(`[AmplifyResiliency] Timeout fetching auth session (attempt ${attempts}/${maxRetries + 1})`);
        } else if (error.name === 'NetworkError') {
          logger.warn(`[AmplifyResiliency] Network error fetching auth session (attempt ${attempts}/${maxRetries + 1}):`, error);
        } else {
          // Other errors (auth errors, etc.)
          logger.warn(`[AmplifyResiliency] Error fetching auth session (attempt ${attempts}/${maxRetries + 1}):`, error);
          
          // For auth errors, don't retry
          if (error.name === 'NotAuthorizedException' || error.name === 'UserNotFoundException') {
            break;
          }
        }
        
        // Track this failure for future reference
        trackCognitoFailure(error);
        
        // If we've exceeded max retries, break out
        if (attempts > maxRetries) {
          break;
        }
        
        // Wait before retrying with exponential backoff
        const delay = Math.min(2 ** attempts * 500, 2000); // Max 2-second delay
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
    
    // If we couldn't get the session after retries, try fallbacks
    if (fallbackToCache && cachedValues.session) {
      const age = Date.now() - cachedValues.timestamp;
      logger.info(`[AmplifyResiliency] Using cached auth session (${age / 1000}s old)`);
      return cachedValues.session;
    }
    
    // Re-throw the last error if all fallbacks fail
    throw lastError;
  } catch (error) {
    logger.error('[AmplifyResiliency] All attempts to fetch auth session failed:', error);
    throw error;
  }
};

/**
 * Resilient wrapper for updateUserAttributes that includes retries, timeouts,
 * and performance logging.
 * 
 * @param {Object} params The parameters for updateUserAttributes
 * @returns {Promise<Object>} The result of the updateUserAttributes operation
 */
export async function resilientUpdateUserAttributes(params) {
  const CACHE_KEY = 'user_attributes_update';
  const MAX_RETRIES = 2;
  const TIMEOUT_MS = 5000;
  
  const startTime = performance.now();
  let success = false;
  let error = null;
  let retryCount = 0;
  
  // Store the update attempt in cache
  try {
    const updateData = {
      attributes: params.userAttributes,
      timestamp: Date.now()
    };
    localStorage.setItem(CACHE_KEY, JSON.stringify(updateData));
  } catch (e) {
    logger.warn('[Amplify] Failed to cache user attributes update:', e);
  }
  
  while (retryCount <= MAX_RETRIES && !success) {
    try {
      // Create a promise that will timeout
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error('Operation timed out')), TIMEOUT_MS);
      });
      
      // Create the actual operation promise
      const operationPromise = updateUserAttributes(params);
      
      // Race the timeout against the operation
      const result = await Promise.race([operationPromise, timeoutPromise]);
      
      // If we get here, the operation succeeded before timeout
      success = true;
      
      // Calculate and log performance metrics
      const endTime = performance.now();
      const duration = endTime - startTime;
      
      logger.info('[Amplify] updateUserAttributes completed successfully', {
        duration,
        retries: retryCount,
        attributeCount: Object.keys(params.userAttributes || {}).length
      });
      
      // Clear the cached update attempt on success
      try {
        localStorage.removeItem(CACHE_KEY);
      } catch (e) {
        logger.warn('[Amplify] Failed to clear cached user attributes update:', e);
      }
      
      return result;
    } catch (e) {
      error = e;
      retryCount++;
      
      // Log the error and retry information
      logger.warn(`[Amplify] updateUserAttributes failed (attempt ${retryCount}/${MAX_RETRIES + 1})`, {
        error: e.message,
        code: e.code,
        name: e.name
      });
      
      // Wait before retrying (simple exponential backoff)
      if (retryCount <= MAX_RETRIES) {
        const backoffMs = Math.min(1000 * Math.pow(2, retryCount - 1), 10000);
        await new Promise(resolve => setTimeout(resolve, backoffMs));
      }
    }
  }
  
  // If we've exhausted retries, log a final error and throw
  if (!success) {
    const endTime = performance.now();
    const duration = endTime - startTime;
    
    logger.error('[Amplify] updateUserAttributes failed after all retries', {
      duration,
      retries: retryCount,
      error: error.message,
      code: error.code
    });
    
    throw error;
  }
} 
/**
 * Unified function to get AWS AppCache value with fallback to Cognito
 * This provides a resilient data access pattern when Cognito may be unreliable
 * 
 * @param {string} key - The cache key to retrieve
 * @param {Function} cognitoFetchFn - Function to fetch from Cognito if cache misses
 * @param {Object} options - Options including fallback value
 * @returns {Promise<any>} The value from cache, Cognito, or fallback
 */
export const getResiliantCacheValue = async (key, cognitoFetchFn, options = {}) => {
  const { 
    fallbackValue = null,
    cacheTTL = 3600000, // 1 hour default
    logPrefix = '[AppCache]'
  } = options;
  
  try {
    // First try AppCache if available
    if (typeof window !== 'undefined' && window.__APP_CACHE) {
      const cachedValue = window.__APP_CACHE[key];
      const cachedTime = window.__APP_CACHE[key + '_timestamp'];
      
      // If we have a valid cached value and it's not expired
      if (cachedValue && cachedTime && (Date.now() - cachedTime < cacheTTL)) {
        logger.debug(`${logPrefix} Using cached value for ${key} (${(Date.now() - cachedTime) / 1000}s old)`);
        return cachedValue;
      }
    }
    
    // Check circuit breaker before trying Cognito
    if (!shouldAttemptCognitoRequest()) {
      logger.warn(`${logPrefix} Circuit breaker is OPEN, using fallback value for ${key}`);
      return fallbackValue;
    }
    
    // No cache hit, try Cognito
    logger.debug(`${logPrefix} Cache miss for ${key}, fetching from Cognito`);
    const value = await cognitoFetchFn();
    
    // Save to AppCache for future use
    if (typeof window !== 'undefined') {
      if (!window.__APP_CACHE) window.__APP_CACHE = {};
      window.__APP_CACHE[key] = value;
      window.__APP_CACHE[key + '_timestamp'] = Date.now();
    }
    
    // Track success for circuit breaker
    trackCognitoSuccess();
    
    return value;
  } catch (error) {
    logger.error(`${logPrefix} Error fetching ${key}:`, error);
    
    // Track failure for circuit breaker
    trackCognitoFailure(error);
    
    // Return fallback
    return fallbackValue;
  }
};

/**
 * Unified function to get AWS AppCache value with fallback to Cognito
 * This provides a resilient data access pattern when Cognito may be unreliable
 * 
 * @param {string} key - The cache key to retrieve
 * @param {Function} cognitoFetchFn - Function to fetch from Cognito if cache misses
 * @param {Object} options - Options including fallback value
 * @returns {Promise<any>} The value from cache, Cognito, or fallback
 */
export const getResiliantCacheValue = async (key, cognitoFetchFn, options = {}) => {
  const { 
    fallbackValue = null,
    cacheTTL = 3600000, // 1 hour default
    logPrefix = '[AppCache]'
  } = options;
  
  try {
    // First try AppCache if available
    if (typeof window !== 'undefined' && window.__APP_CACHE) {
      const cachedValue = window.__APP_CACHE[key];
      const cachedTime = window.__APP_CACHE[key + '_timestamp'];
      
      // If we have a valid cached value and it's not expired
      if (cachedValue && cachedTime && (Date.now() - cachedTime < cacheTTL)) {
        logger.debug(`${logPrefix} Using cached value for ${key} (${(Date.now() - cachedTime) / 1000}s old)`);
        return cachedValue;
      }
    }
    
    // Check circuit breaker before trying Cognito
    if (!shouldAttemptCognitoRequest()) {
      logger.warn(`${logPrefix} Circuit breaker is OPEN, using fallback value for ${key}`);
      return fallbackValue;
    }
    
    // No cache hit, try Cognito
    logger.debug(`${logPrefix} Cache miss for ${key}, fetching from Cognito`);
    const value = await cognitoFetchFn();
    
    // Save to AppCache for future use
    if (typeof window !== 'undefined') {
      if (!window.__APP_CACHE) window.__APP_CACHE = {};
      window.__APP_CACHE[key] = value;
      window.__APP_CACHE[key + '_timestamp'] = Date.now();
    }
    
    // Track success for circuit breaker
    trackCognitoSuccess();
    
    return value;
  } catch (error) {
    logger.error(`${logPrefix} Error fetching ${key}:`, error);
    
    // Track failure for circuit breaker
    trackCognitoFailure(error);
    
    // Return fallback
    return fallbackValue;
  }
};
