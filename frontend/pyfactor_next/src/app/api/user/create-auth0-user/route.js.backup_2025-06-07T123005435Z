import { NextResponse } from 'next/server';
import { cookies } from 'next/headers';
import { v4 as uuidv4 } from 'uuid';

export async function POST(request) {
  console.log('[AUTH DEBUG] üì• create-auth0-user POST request received');
  const startTime = Date.now();
  try {
        console.log('[AUTH DEBUG] üç™ Updating session cookies with tenant ID:', existingUser.tenant_id);
        const cookieStore = await cookies();
    const sessionCookie = cookieStore.get('appSession');
    
    if (!sessionCookie) {
      console.error('[Create Auth0 User] No Auth0 session cookie found');
      return NextResponse.json({ error: 'No Auth0 session found' }, { status: 401 });
    }
    
    let sessionData;
    try {
      sessionData = JSON.parse(Buffer.from(sessionCookie.value, 'base64').toString());
    } catch (parseError) {
      console.error('[Create Auth0 User] Error parsing session cookie:', parseError);
      return NextResponse.json({ error: 'Invalid session data' }, { status: 401 });
    }
    
    console.log('[Create Auth0 User] Session data structure:', {
      hasUser: !!sessionData.user,
      hasAccessToken: !!sessionData.accessToken,
      userEmail: sessionData.user?.email,
      userSub: sessionData.user?.sub,
      sessionKeys: Object.keys(sessionData)
    });
    
    const { user, accessToken } = sessionData;
    
    if (!user) {
      console.error('[Create Auth0 User] No user in session data. Session structure:', sessionData);
      return NextResponse.json({ 
        error: 'Invalid session - missing user data',
        fallback: true,
        tenant_id: uuidv4(),
        current_step: 'business_info',
        needs_onboarding: true
      }, { status: 200 });
    }
    
    console.log('[Create Auth0 User] Processing Auth0 user:', {
      email: user.email,
      sub: user.sub,
      name: user.name
    });
    
    const apiBaseUrl = process.env.NEXT_PUBLIC_API_URL || process.env.BACKEND_API_URL || 'https://127.0.0.1:8000';
    console.log('[Create Auth0 User] Using API base URL:', apiBaseUrl);
    
    // ENHANCED: Check for existing tenant ID in multiple places
    console.log('[Create Auth0 User] === ENHANCED EXISTING USER DETECTION ===');
    
    // Method 1: Check session for existing tenant ID
    let existingTenantId = sessionData.user?.tenant_id || sessionData.user?.tenantId;
    if (existingTenantId) {
      console.log('[Create Auth0 User] Found existing tenant ID in session:', existingTenantId);
    }
    
    // Method 2: Check cookies for tenant ID
    if (!existingTenantId) {
      const tenantCookie = cookieStore.get('user_tenant_id');
      if (tenantCookie) {
        existingTenantId = tenantCookie.value;
        console.log('[Create Auth0 User] Found existing tenant ID in cookie:', existingTenantId);
      }
    }
    
    // Method 3: Check for auth0_sub-based cookie storage
    if (!existingTenantId) {
      const auth0SubHash = Buffer.from(user.sub).toString('base64').substring(0, 16);
      const subBasedCookie = cookieStore.get(`tenant_${auth0SubHash}`);
      if (subBasedCookie) {
        existingTenantId = subBasedCookie.value;
        console.log('[Create Auth0 User] Found existing tenant ID via Auth0 sub:', existingTenantId);
      }
    }
    
    // Step 1: Try Django backend lookup (if not check-only)
    let existingUser = null;
    if (!checkOnly) {
    try {
      console.log('[Create Auth0 User] Checking for existing user with Auth0 token');
      
      const existingUserResponse = await fetch(`${apiBaseUrl}/api/users/me/`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/json',
          'Accept': 'application/json',
        }
      });
      
      console.log('[Create Auth0 User] Existing user lookup status:', existingUserResponse.status);
      
      if (existingUserResponse.ok) {
        existingUser = await existingUserResponse.json();
          console.log('[Create Auth0 User] Found existing user in backend:', {
          email: existingUser.email,
          tenant_id: existingUser.tenant_id,
          onboarding_completed: existingUser.onboarding_completed,
          needs_onboarding: existingUser.needs_onboarding
        });
          
          // Store tenant ID for future use
          existingTenantId = existingUser.tenant_id;
        
        // User exists - return their existing data
        console.log('[Create Auth0 User] RETURNING EXISTING USER WITH TENANT ID:', existingUser.tenant_id);
        
        // Prepare the response with both tenant_id and tenantId for consistency
        const response = NextResponse.json({
          success: true,
          message: 'Existing user found',
          isExistingUser: true,
          user_id: existingUser.id,
          tenant_id: existingUser.tenant_id,
          tenantId: existingUser.tenant_id, // Add tenantId for frontend consistency
          email: existingUser.email,
          needs_onboarding: existingUser.needs_onboarding !== false,
          onboardingCompleted: existingUser.onboarding_completed === true,
          current_step: existingUser.current_onboarding_step || 'business_info'
        });
        
        // Update session cookie with tenant ID
        // This ensures the session has the correct tenant ID
        try {
          const cookieStore = await cookies();
          const sessionCookie = cookieStore.get('appSession');
          
          if (sessionCookie) {
            const sessionCookie = cookieStore.get('appSession');
          
          if (sessionCookie) {
            console.log('[AUTH DEBUG] üç™ Found existing appSession cookie');
            const sessionData = JSON.parse(Buffer.from(sessionCookie.value, 'base64').toString());
            console.log('[AUTH DEBUG] üìÑ Session data parsed successfully. User sub:', sessionData.user?.sub || 'not found');
            
            // Update user object in session with tenant ID
            const updatedSession = {
              ...sessionData,
              user: {
                ...sessionData.user,
                tenant_id: existingUser.tenant_id,
                tenantId: existingUser.tenant_id,
                needsOnboarding: existingUser.needs_onboarding !== false,
                onboardingCompleted: existingUser.onboarding_completed === true
              }
            };
            
            response.cookies.set('appSession', Buffer.from(JSON.stringify(updatedSession)).toString('base64'), {
              httpOnly: true,
              secure: process.env.NODE_ENV === 'production',
              sameSite: 'lax',
              maxAge: 60 * 60 * 24 * 7 // 7 days
            });
            
            // Store tenant ID in dedicated cookie for future lookups
            response.cookies.set('user_tenant_id', existingUser.tenant_id, {
              httpOnly: true,
              secure: process.env.NODE_ENV === 'production',
              sameSite: 'lax',
              maxAge: 60 * 60 * 24 * 30 // 30 days
            });
            
            if (sessionData.user?.sub) {
              const auth0SubHash = Buffer.from(sessionData.user.sub).toString('base64').substring(0, 16);
              response.cookies.set(`tenant_${auth0SubHash}`, existingUser.tenant_id, {
                httpOnly: true,
                secure: process.env.NODE_ENV === 'production',
                sameSite: 'lax',
                maxAge: 60 * 60 * 24 * 30 // 30 days
              });
            }
          }
        } catch (cookieError) {
          console.error('[AUTH DEBUG] ‚ùå Error updating session cookie:', cookieError);
          // Continue with response even if cookie update fails
        }
        
        if (response) { return response; }
      } else {
          console.log('[Create Auth0 User] User does not exist in backend (status:', existingUserResponse.status, ')');
      }
    } catch (error) {
      console.warn('[Create Auth0 User] Error checking existing user:', error.message);
    }
    }
    
    // If we have an existing tenant ID from session/cookies, use it instead of creating new one
    if (existingTenantId) {
      console.log('[Create Auth0 User] RETURNING EXISTING TENANT ID:', existingTenantId);
      
      // Update session to ensure tenant ID is preserved
      const updatedSession = {
        ...sessionData,
        user: {
          ...sessionData.user,
          tenant_id: existingTenantId,
          tenantId: existingTenantId,
          needs_onboarding: sessionData.user?.needsOnboarding !== false,
          onboarding_completed: sessionData.user?.onboardingCompleted === true
        }
      };
      
      const response = NextResponse.json({
        success: true,
        message: 'Existing user found (session/cookie)',
        isExistingUser: true,
        tenantId: existingTenantId,
        tenant_id: existingTenantId,
        email: user.email,
        needs_onboarding: sessionData.user?.needsOnboarding !== false,
        onboardingCompleted: sessionData.user?.onboardingCompleted === true,
        current_step: sessionData.user?.currentStep || 'business_info'
      });
      
      // Update session cookie with tenant ID
      response.cookies.set('appSession', Buffer.from(JSON.stringify(updatedSession)).toString('base64'), {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'lax',
        maxAge: 60 * 60 * 24 * 7 // 7 days
      });
      
      // Store tenant ID in dedicated cookie for future lookups
      const auth0SubHash = Buffer.from(user.sub).toString('base64').substring(0, 16);
      response.cookies.set(`tenant_${auth0SubHash}`, existingTenantId, {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'lax',
        maxAge: 60 * 60 * 24 * 30 // 30 days
      });
      
      response.cookies.set('user_tenant_id', existingTenantId, {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'lax',
        maxAge: 60 * 60 * 24 * 30 // 30 days
      });
      
      return response;
    }
    
    // Step 2: Create new user only if no existing tenant ID found
    console.log('[Create Auth0 User] Creating new user - no existing tenant ID found');
    const tenantId = uuidv4(); // Generate new tenant ID for new user
    
    try {
      const createUserResponse = await fetch(`${apiBaseUrl}/api/auth0/create-user/`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/json',
          'Accept': 'application/json',
        },
        body: JSON.stringify({
          auth0_sub: user.sub,
          email: user.email,
          first_name: user.given_name || '',
          last_name: user.family_name || '',
          name: user.name || '',
          picture: user.picture || '',
          tenant_id: tenantId,
          needs_onboarding: true,
          onboarding_status: 'business_info'
        })
      });
      
      console.log('[Create Auth0 User] Create user response status:', createUserResponse.status);
      
      if (createUserResponse.ok) {
        const newUser = await createUserResponse.json();
        console.log('[Create Auth0 User] Successfully created new user:', {
          user_id: newUser.id,
          tenant_id: newUser.tenant_id,
          email: newUser.email
        });
        
        // Update session cookie with tenant ID for consistency
        const updatedSession = {
          ...sessionData,
          user: {
            ...sessionData.user,
            tenant_id: newUser.tenant_id,
            tenantId: newUser.tenant_id,
            needs_onboarding: true,
            onboarding_completed: false
          }
        };
        
        const response = NextResponse.json({
          success: true,
          message: 'New user created successfully',
          isExistingUser: false,
          user_id: newUser.id,
          tenant_id: newUser.tenant_id,
          tenantId: newUser.tenant_id,
          email: newUser.email,
          needs_onboarding: true,
          onboardingCompleted: false,
          current_step: 'business_info'
        });
        
        // Update session cookie
        response.cookies.set('appSession', Buffer.from(JSON.stringify(updatedSession)).toString('base64'), {
          httpOnly: true,
          secure: process.env.NODE_ENV === 'production',
          sameSite: 'lax',
          maxAge: 60 * 60 * 24 * 7 // 7 days
        });
        
        // Store tenant ID for future lookups
        const auth0SubHash = Buffer.from(user.sub).toString('base64').substring(0, 16);
        response.cookies.set(`tenant_${auth0SubHash}`, newUser.tenant_id, {
          httpOnly: true,
          secure: process.env.NODE_ENV === 'production',
          sameSite: 'lax',
          maxAge: 60 * 60 * 24 * 30 // 30 days
        });
        
        response.cookies.set('user_tenant_id', newUser.tenant_id, {
          httpOnly: true,
          secure: process.env.NODE_ENV === 'production',
          sameSite: 'lax',
          maxAge: 60 * 60 * 24 * 30 // 30 days
        });
        
        return response;
      } else {
        const errorText = await createUserResponse.text();
        console.error('[Create Auth0 User] Failed to create user in Django:', errorText);
        
        // Handle duplicate user case
        if (createUserResponse.status === 409 || errorText.includes('already exists')) {
          console.log('[Create Auth0 User] User already exists (409), attempting to fetch existing user');
          
          // Retry getting the existing user
          try {
            const retryResponse = await fetch(`${apiBaseUrl}/api/users/me/`, {
              method: 'GET',
              headers: {
                'Authorization': `Bearer ${accessToken}`,
                'Content-Type': 'application/json',
                'Accept': 'application/json',
              }
            });
            
            if (retryResponse.ok) {
              const existingUserData = await retryResponse.json();
              return NextResponse.json({
                success: true,
                message: 'Found existing user after conflict',
                isExistingUser: true,
                user_id: existingUserData.id,
                tenant_id: existingUserData.tenant_id,
                tenantId: existingUserData.tenant_id,
                email: existingUserData.email,
                needs_onboarding: existingUserData.needs_onboarding !== false,
                onboardingCompleted: existingUserData.onboarding_completed === true,
                current_step: existingUserData.current_onboarding_step || 'business_info'
              });
            }
          } catch (retryError) {
            console.error('[Create Auth0 User] Failed to retry user lookup:', retryError);
          }
        }
        
        throw new Error(`Django API error: ${errorText}`);
      }
    } catch (error) {
      console.error('[Create Auth0 User] Error creating user in Django:', error);
      
      // ENHANCED FALLBACK: Check for existing tenant ID one more time before creating new one
      if (!existingTenantId) {
        console.log('[Create Auth0 User] No existing tenant ID found anywhere, creating new one for fallback');
      } else {
        console.log('[Create Auth0 User] Using existing tenant ID for fallback:', existingTenantId);
      }
      
      const fallbackTenantId = existingTenantId || tenantId;
      
      // Update session with tenant ID for consistency
      const updatedSession = {
        ...sessionData,
        user: {
          ...sessionData.user,
          tenant_id: fallbackTenantId,
          tenantId: fallbackTenantId,
          needs_onboarding: true,
          onboarding_completed: false
        }
      };
      
      const response = NextResponse.json({
        success: false,
        fallback: true,
        message: 'Backend unavailable, using session fallback',
        isExistingUser: !!existingTenantId,
        tenant_id: fallbackTenantId,
        tenantId: fallbackTenantId,
        email: user.email,
        needs_onboarding: true,
        onboardingCompleted: false,
        current_step: 'business_info',
        error: error.message
      }, { status: 200 });
      
      // Update session cookie
      response.cookies.set('appSession', Buffer.from(JSON.stringify(updatedSession)).toString('base64'), {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'lax',
        maxAge: 60 * 60 * 24 * 7 // 7 days
      });
      
      // Store tenant ID for future lookups if it's new
      if (fallbackTenantId) {
        const auth0SubHash = Buffer.from(user.sub).toString('base64').substring(0, 16);
        response.cookies.set(`tenant_${auth0SubHash}`, fallbackTenantId, {
          httpOnly: true,
          secure: process.env.NODE_ENV === 'production',
          sameSite: 'lax',
          maxAge: 60 * 60 * 24 * 30 // 30 days
        });
        
        response.cookies.set('user_tenant_id', fallbackTenantId, {
          httpOnly: true,
          secure: process.env.NODE_ENV === 'production',
          sameSite: 'lax',
          maxAge: 60 * 60 * 24 * 30 // 30 days
        });
      }
      
      return response;
    }
    
  } catch (error) {
    console.error('[Create Auth0 User] Unexpected error:', error);
    return NextResponse.json({ 
      error: 'Internal server error',
      message: error.message 
    }, { status: 500 });
  }
} 