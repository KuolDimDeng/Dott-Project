"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[62052],{62052:(e,t,i)=>{i.d(t,{l:()=>w});var a,r=i(62904),s=i(94225),n=i(39641);let o={keyPrefix:"aws-amplify-cache",capacityInBytes:1048576,itemMaxSize:21e4,defaultTTL:2592e5,defaultPriority:5,warningThreshold:.8},h="CurSize";function l(e){let t=0;t=e.length;for(let i=e.length;i>=0;i-=1){let a=e.charCodeAt(i);a>127&&a<=2047?t+=1:a>2047&&a<=65535&&(t+=2),a>=56320&&a<=57343&&(i-=1)}return t}function c(){return new Date().getTime()}let y=e=>`${e}${h}`;var g=i(33182);!function(e){e.NoCacheItem="NoCacheItem",e.NullNextNode="NullNextNode",e.NullPreviousNode="NullPreviousNode"}(a||(a={}));let u={[a.NoCacheItem]:{message:"Item not found in the cache storage."},[a.NullNextNode]:{message:"Next node is null."},[a.NullPreviousNode]:{message:"Previous node is null."}},f=(0,g.p)(u),d=new r.C("StorageCache");class m{constructor({config:e,keyValueStorage:t}){this.config={...o,...e},this.keyValueStorage=t,this.sanitizeConfig()}getModuleName(){return"Cache"}configure(e){return e&&(e.keyPrefix&&d.warn("keyPrefix can not be re-configured on an existing Cache instance."),this.config={...this.config,...e}),this.sanitizeConfig(),this.config}async getCurrentCacheSize(){let e=await this.getStorage().getItem(y(this.config.keyPrefix));return e||(await this.getStorage().setItem(y(this.config.keyPrefix),"0"),e="0"),Number(e)}async setItem(e,t,i){if(d.debug(`Set item: key is ${e}, value is ${t} with options: ${i}`),!e||e===h)return void d.warn(`Invalid key: should not be empty or reserved key: '${h}'`);if(void 0===t)return void d.warn("The value of item should not be undefined!");let a={priority:i?.priority!==void 0?i.priority:this.config.defaultPriority,expires:i?.expires!==void 0?i.expires:this.config.defaultTTL+c()};if(a.priority<1||a.priority>5)return void d.warn("Invalid parameter: priority due to out or range. It should be within 1 and 5.");let r=`${this.config.keyPrefix}${e}`,s=this.fillCacheItem(r,t,a);if(s.byteSize>this.config.itemMaxSize)return void d.warn(`Item with key: ${e} you are trying to put into is too big!`);try{let e=await this.getStorage().getItem(r);if(e&&await this.removeCacheItem(r,JSON.parse(e).byteSize),await this.isCacheFull(s.byteSize)){let e=await this.clearInvalidAndGetRemainingKeys();if(await this.isCacheFull(s.byteSize)){let t=await this.sizeToPop(s.byteSize);await this.popOutItems(e,t)}}return this.setCacheItem(r,s)}catch(e){d.warn(`setItem failed! ${e}`)}}async getItem(e,t){let i;if(d.debug(`Get item: key is ${e} with options ${t}`),!e||e===h)return d.warn(`Invalid key: should not be empty or reserved key: '${h}'`),null;let a=`${this.config.keyPrefix}${e}`;try{if(i=await this.getStorage().getItem(a),null!=i)if(!await this.isExpired(a))return(await this.updateVisitedTime(JSON.parse(i),a)).data;else await this.removeCacheItem(a,JSON.parse(i).byteSize);if(t?.callback){let i=t.callback();return null!==i&&await this.setItem(e,i,t),i}return null}catch(e){return d.warn(`getItem failed! ${e}`),null}}async removeItem(e){if(d.debug(`Remove item: key is ${e}`),!e||e===h)return void d.warn(`Invalid key: should not be empty or reserved key: '${h}'`);let t=`${this.config.keyPrefix}${e}`;try{let e=await this.getStorage().getItem(t);e&&await this.removeCacheItem(t,JSON.parse(e).byteSize)}catch(e){d.warn(`removeItem failed! ${e}`)}}async getAllKeys(){try{return await this.getAllCacheKeys()}catch(e){return d.warn(`getAllkeys failed! ${e}`),[]}}getStorage(){return this.keyValueStorage}async isExpired(e){let t=await this.getStorage().getItem(e);f(null!==t,a.NoCacheItem,`Key: ${e}`);let i=JSON.parse(t);return c()>=i.expires}async removeCacheItem(e,t){let i=await this.getStorage().getItem(e);f(null!==i,a.NoCacheItem,`Key: ${e}`);let r=t??JSON.parse(i).byteSize;await this.decreaseCurrentSizeInBytes(r);try{await this.getStorage().removeItem(e)}catch(e){await this.increaseCurrentSizeInBytes(r),d.error(`Failed to remove item: ${e}`)}}fillCacheItem(e,t,i){let a={key:e,data:t,timestamp:c(),visitedTime:c(),priority:i.priority??0,expires:i.expires??0,type:typeof t,byteSize:0};return a.byteSize=l(JSON.stringify(a)),a.byteSize=l(JSON.stringify(a)),a}sanitizeConfig(){this.config.itemMaxSize>this.config.capacityInBytes&&(d.error("Invalid parameter: itemMaxSize. It should be smaller than capacityInBytes. Setting back to default."),this.config.itemMaxSize=o.itemMaxSize),(this.config.defaultPriority>5||this.config.defaultPriority<1)&&(d.error("Invalid parameter: defaultPriority. It should be between 1 and 5. Setting back to default."),this.config.defaultPriority=o.defaultPriority),(Number(this.config.warningThreshold)>1||0>Number(this.config.warningThreshold))&&(d.error("Invalid parameter: warningThreshold. It should be between 0 and 1. Setting back to default."),this.config.warningThreshold=o.warningThreshold),this.config.capacityInBytes>5242880&&(d.error("Cache Capacity should be less than 5MB. Setting back to default. Setting back to default."),this.config.capacityInBytes=o.capacityInBytes)}async increaseCurrentSizeInBytes(e){let t=await this.getCurrentCacheSize();await this.getStorage().setItem(y(this.config.keyPrefix),(t+e).toString())}async decreaseCurrentSizeInBytes(e){let t=await this.getCurrentCacheSize();await this.getStorage().setItem(y(this.config.keyPrefix),(t-e).toString())}async updateVisitedTime(e,t){return e.visitedTime=c(),await this.getStorage().setItem(t,JSON.stringify(e)),e}async setCacheItem(e,t){await this.increaseCurrentSizeInBytes(t.byteSize);try{await this.getStorage().setItem(e,JSON.stringify(t))}catch(e){await this.decreaseCurrentSizeInBytes(t.byteSize),d.error(`Failed to set item ${e}`)}}async sizeToPop(e){let t=await this.getCurrentCacheSize()+e-this.config.capacityInBytes,i=(1-this.config.warningThreshold)*this.config.capacityInBytes;return t>i?t:i}async isCacheFull(e){return e+await this.getCurrentCacheSize()>this.config.capacityInBytes}async popOutItems(e,t){let i=[],a=t;for(let t of e){let e=await this.getStorage().getItem(t);if(null!=e){let t=JSON.parse(e);i.push(t)}}for(let e of(i.sort((e,t)=>e.priority>t.priority?-1:e.priority<t.priority?1:e.visitedTime<t.visitedTime?-1:1),i))if(await this.removeCacheItem(e.key,e.byteSize),(a-=e.byteSize)<=0)return}async clearInvalidAndGetRemainingKeys(){let e=[];for(let t of(await this.getAllCacheKeys({omitSizeKey:!0})))await this.isExpired(t)?await this.removeCacheItem(t):e.push(t);return e}async clear(){d.debug("Clear Cache");try{for(let e of(await this.getAllKeys())){let t=`${this.config.keyPrefix}${e}`;await this.getStorage().removeItem(t)}}catch(e){d.warn(`clear failed! ${e}`)}}}let I=new r.C("StorageCache");class S extends m{constructor(e){let t=(0,n.p)();super({config:e,keyValueStorage:new s.U(t)}),this.storage=t,this.getItem=this.getItem.bind(this),this.setItem=this.setItem.bind(this),this.removeItem=this.removeItem.bind(this)}async getAllCacheKeys(e){let{omitSizeKey:t}=e??{},i=[];for(let e=0;e<this.storage.length;e++){let a=this.storage.key(e);(!t||a!==y(this.config.keyPrefix))&&a?.startsWith(this.config.keyPrefix)&&i.push(a.substring(this.config.keyPrefix.length))}return i}createInstance(e){return e.keyPrefix&&e.keyPrefix!==o.keyPrefix||(I.error("invalid keyPrefix, setting keyPrefix with timeStamp"),e.keyPrefix=c.toString()),new S(e)}}let w=new S}}]);