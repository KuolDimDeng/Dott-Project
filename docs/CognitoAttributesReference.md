# Cognito Attributes Reference

This document serves as the source of truth for all Cognito user attributes used throughout the application. Developers should refer to this document when working with user attributes to ensure consistent naming, proper validation, and correct usage.

## Purpose

The goal of this reference is to:

1. Maintain consistency in attribute naming and casing across the codebase
2. Document validation rules for each attribute
3. Provide clear descriptions of each attribute's purpose
4. Prevent bugs caused by inconsistent attribute naming

## Standard Attributes

These are the standard attributes provided by Amazon Cognito.

| Attribute Name | Type | Required | Mutable | Min Length | Max Length | Description |
|---------------|------|----------|---------|------------|------------|-------------|
| `sub` | String | Yes | No | - | - | Unique identifier for the user (generated by Cognito) |
| `email` | String | Yes | Yes | 5 | 254 | User's email address (verified) |
| `given_name` | String | No | Yes | 1 | 256 | User's first name |
| `family_name` | String | No | Yes | 1 | 256 | User's last name |

## Custom Attributes

These are custom attributes defined for our application. **Note the exact casing of each attribute - this must be followed precisely in code.**

| Attribute Name | Type | Required | Mutable | Min Length | Max Length | Description |
|---------------|------|----------|---------|------------|------------|-------------|
| `custom:acctstatus` | String | No | Yes | 6 | 9 | Account status (e.g., "active", "suspended") |
| `custom:attrversion` | String | No | Yes | 5 | 10 | Version of the attribute schema being used |
| `custom:businesscountry` | String | No | Yes | 2 | 3 | ISO country code of the business |
| `custom:businessid` | String | No | Yes | 36 | 36 | UUID for the business |
| `custom:businessname` | String | No | Yes | 1 | 256 | Name of the business |
| `custom:businessstate` | String | No | Yes | 1 | 256 | State/province of the business |
| `custom:businesssubtypes` | String | No | Yes | 1 | 2048 | JSON array of business subtypes |
| `custom:businesstype` | String | No | Yes | 1 | 256 | Primary type of business |
| `custom:created_at` | String | No | Yes | 1 | 24 | ISO timestamp of user creation |
| `custom:currency` | String | No | Yes | 0 | 5 | Default currency code (e.g., "USD") |
| `custom:dateformat` | String | No | Yes | 1 | 20 | Preferred date format (e.g., "MM/DD/YYYY") |
| `custom:datefounded` | String | No | Yes | 1 | 10 | Date the business was founded (ISO format) |
| `custom:employeeid` | String | No | Yes | 3 | 15 | Internal employee identifier |
| `custom:language` | String | No | Yes | 0 | 10 | Preferred language code (e.g., "en-US") |
| `custom:lastlogin` | String | No | Yes | 24 | 24 | ISO timestamp of last login |
| `custom:legalstructure` | String | No | Yes | 1 | 256 | Legal structure of business (e.g., "LLC") |
| `custom:onboarding` | String | No | Yes | 1 | 256 | Onboarding status information |
| `custom:paymentid` | String | No | Yes | 1 | 256 | ID from payment processor |
| `custom:paymentmethod` | String | No | Yes | 0 | 128 | Default payment method |
| `custom:payverified` | String | No | Yes | 4 | 5 | Payment verification status ("true"/"false") |
| `custom:preferences` | String | No | Yes | 2 | 2048 | JSON string of user preferences |
| `custom:requirespayment` | String | No | Yes | 1 | 10 | Whether payment is required ("true"/"false") |
| `custom:setupdone` | String | No | Yes | 4 | 5 | Setup completion status ("true"/"false") |
| `custom:subplan` | String | No | Yes | 4 | 12 | Subscription plan identifier |
| `custom:subscriptioninterval` | String | No | Yes | 6 | 7 | Billing interval ("monthly"/"yearly") |
| `custom:subscriptionstatus` | String | No | Yes | 6 | 10 | Status of subscription |
| `custom:tenant_ID` | String | No | Yes | 0 | 36 | **Tenant ID (UUID format) - note the uppercase "ID"** |
| `custom:timezone` | String | No | Yes | 1 | 35 | Preferred timezone (e.g., "America/New_York") |
| `custom:updated_at` | String | No | Yes | 1 | 24 | ISO timestamp of last update |
| `custom:userrole` | String | No | Yes | 4 | 6 | User role in system (e.g., "admin", "user") |

## Usage Best Practices

1. **Always use the exact attribute name** including the correct casing as shown in this document
2. **Validate attribute values** before attempting to save them to ensure they meet length and format requirements
3. **Use defensive coding** when retrieving attributes (e.g., check if the attribute exists before using it)
4. **Consider creating utility functions** that reference this document programmatically to get/set attributes

## Code Examples

### Correct Attribute Access

```javascript
// CORRECT: Using the exact attribute name with correct casing
const tenantId = userAttributes['custom:tenant_ID'];

// INCORRECT: Wrong casing
const tenantId = userAttributes['custom:tenant_id']; // Will return undefined!
const tenantId = userAttributes['custom:tenantId']; // Will return undefined!
```

### Defensive Attribute Access

```javascript
function getTenantId(userAttributes) {
  // Always use the exact casing from this document
  return userAttributes?.['custom:tenant_ID'] || null;
}

function getBusinessName(userAttributes) {
  return userAttributes?.['custom:businessname'] || 'Unknown Business';
}
```

## Common Pitfalls

1. **Inconsistent casing**: The most common error is using incorrect casing (e.g., 'custom:tenant_id' instead of 'custom:tenant_ID').
2. **Missing validation**: Not checking length constraints before saving attributes.
3. **Hard-coded attribute names**: Embedding attribute names directly in code rather than using constants.
4. **Not handling missing attributes**: Assuming attributes will always be present.

## Utility Implementation

Consider implementing a utility class or module that enforces these conventions:

```javascript
// Example CognitoAttributes utility module
export const CognitoAttributes = {
  // Standard attributes
  SUB: 'sub',
  EMAIL: 'email',
  GIVEN_NAME: 'given_name',
  FAMILY_NAME: 'family_name',
  
  // Custom attributes
  TENANT_ID: 'custom:tenant_ID',
  BUSINESS_NAME: 'custom:businessname',
  BUSINESS_ID: 'custom:businessid',
  USER_ROLE: 'custom:userrole',
  
  // Getter with validation
  getValue(attributes, attributeName) {
    if (!attributes) return null;
    return attributes[attributeName] || null;
  },
  
  // Additional utility methods
  formatUserInitials(attributes) {
    const firstName = this.getValue(attributes, this.GIVEN_NAME) || '';
    const lastName = this.getValue(attributes, this.FAMILY_NAME) || '';
    
    if (firstName && lastName) {
      return `${firstName.charAt(0).toUpperCase()}${lastName.charAt(0).toUpperCase()}`;
    } else if (firstName) {
      return firstName.charAt(0).toUpperCase();
    } else if (lastName) {
      return lastName.charAt(0).toUpperCase();
    }
    
    const email = this.getValue(attributes, this.EMAIL) || '';
    return email.charAt(0).toUpperCase() || 'U';
  }
};
```

## Validation

We recommend implementing automatic validation for each attribute according to the rules specified in this document. This can be done using a schema validation library or custom functions.

## Future Considerations

1. Consider creating a schema file that can be used programmatically to validate attributes
2. Implement TypeScript types for strongly-typed attribute access
3. Create automated tests that verify attribute access patterns in the codebase 