#!/usr/bin/env python3
"""
Script: 20240829_ssl_cert_fix.py
Purpose: Verify SSL certificate setup and provide instructions for fixing browser trust issues
Issue: SSL certificate trust errors (SEC_ERROR_UNKNOWN_ISSUER) causing CORS to fail
Author: Generated by AI assistant
Date: 2024-08-29
Version: v1.0

This script:
1. Checks if required SSL certificates exist
2. Verifies certificate validity
3. Provides instructions for making browsers trust the self-signed certificates
4. Updates script registry with execution status

Execution:
    cd /Users/kuoldeng/projectx/backend/pyfactor
    python scripts/20240829_ssl_cert_fix.py

"""

import os
import sys
import logging
import subprocess
import datetime
import ssl
from pathlib import Path
from datetime import datetime

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('scripts/ssl_cert_fix.log')
    ]
)
logger = logging.getLogger('ssl-cert-fix')

# Define paths
CERT_DIR = Path(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))).parent.parent / 'certificates'
CERT_FILE = CERT_DIR / 'localhost+1.pem'
KEY_FILE = CERT_DIR / 'localhost+1-key.pem'
SCRIPT_REGISTRY = Path('scripts/script_registry.txt')

def check_certificates_exist():
    """Check if the required SSL certificates exist"""
    logger.info(f"Looking for certificates in {CERT_DIR}")
    
    if not CERT_DIR.exists():
        logger.error(f"Certificate directory not found: {CERT_DIR}")
        return False
    
    if not CERT_FILE.exists():
        logger.error(f"Certificate file not found: {CERT_FILE}")
        return False
    
    if not KEY_FILE.exists():
        logger.error(f"Key file not found: {KEY_FILE}")
        return False
    
    logger.info("All certificate files found!")
    return True

def check_certificate_validity():
    """Check if the certificate is valid and get details"""
    try:
        # Try to load the certificate to verify it's valid
        context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
        context.load_cert_chain(
            certfile=str(CERT_FILE),
            keyfile=str(KEY_FILE)
        )
        logger.info("Certificate loaded successfully!")
        
        # Get certificate details
        get_cert_details()
        
        return True
    except Exception as e:
        logger.error(f"Certificate validation failed: {e}")
        return False

def get_cert_details():
    """Get and display certificate details"""
    try:
        cmd = ["openssl", "x509", "-in", str(CERT_FILE), "-text", "-noout"]
        result = subprocess.run(cmd, capture_output=True, text=True)
        
        if result.returncode == 0:
            cert_text = result.stdout
            
            # Extract the important parts
            subject = next((line for line in cert_text.split('\n') if "Subject:" in line), "Subject: Unknown")
            issuer = next((line for line in cert_text.split('\n') if "Issuer:" in line), "Issuer: Unknown")
            valid_from = next((line for line in cert_text.split('\n') if "Not Before:" in line), "Not Before: Unknown")
            valid_to = next((line for line in cert_text.split('\n') if "Not After :" in line), "Not After: Unknown")
            
            logger.info("Certificate Details:")
            logger.info(f"  {subject}")
            logger.info(f"  {issuer}")
            logger.info(f"  {valid_from}")
            logger.info(f"  {valid_to}")
            
            # Check for localhost in subject
            if "localhost" not in subject.lower() and "127.0.0.1" not in subject.lower():
                logger.warning("Certificate does not appear to include localhost or 127.0.0.1!")
            
            return True
        else:
            logger.error(f"Failed to get certificate details: {result.stderr}")
            return False
    except Exception as e:
        logger.error(f"Error getting certificate details: {e}")
        return False

def update_script_registry(success):
    """Update the script registry file with information about this script execution"""
    try:
        # Create registry directory if it doesn't exist
        os.makedirs(os.path.dirname(SCRIPT_REGISTRY), exist_ok=True)
        
        status = "SUCCESS" if success else "FAILURE"
        
        # Append to registry file
        with open(SCRIPT_REGISTRY, 'a') as f:
            f.write(f"{datetime.now().strftime('%Y-%m-%d %H:%M:%S')} - 20240829_ssl_cert_fix.py - Verified SSL certificates and provided trust instructions - {status}\n")
        
        logger.info("Updated script registry")
        return True
    except Exception as e:
        logger.error(f"Failed to update script registry: {e}")
        return False

def print_browser_instructions():
    """Print instructions for getting the browser to trust the certificates"""
    print("\n" + "="*80)
    print("                    BROWSER CERTIFICATE TRUST INSTRUCTIONS")
    print("="*80)
    print("\nYour browser is showing 'SEC_ERROR_UNKNOWN_ISSUER' errors because it doesn't trust")
    print("the self-signed certificates used by the backend server. Here's how to fix it:\n")
    
    print("Option 1: Trust the certificate through your browser (recommended)")
    print("============================================================")
    print("1. Open your browser and navigate to https://127.0.0.1:8000/api/hr/health")
    print("2. You'll see a security warning. In Chrome, click 'Advanced' then 'Proceed'")
    print("   In Firefox, click 'Advanced', then 'Accept the Risk and Continue'")
    print("3. Once you've done this, your browser will trust the certificate for this session\n")
    
    print("Option 2: Install mkcert and create trusted certificates")
    print("====================================================")
    print("1. Install mkcert: brew install mkcert")
    print("2. Install a local CA: mkcert -install")
    print("3. Create certificates: mkcert localhost 127.0.0.1")
    print("4. Copy the generated files to your certificates directory:\n")
    print(f"   mkdir -p {CERT_DIR}")
    print(f"   cp localhost+1.pem {CERT_FILE}")
    print(f"   cp localhost+1-key.pem {KEY_FILE}\n")
    
    print("Option 3: Disable certificate validation in frontend")
    print("=================================================")
    print("Note: This is NOT recommended for production but can help during development")
    print("Add the following to your Axios configuration or fetch requests:")
    print("   axios.create({ httpsAgent: new https.Agent({ rejectUnauthorized: false }) })")
    
    print("\nAfter implementing one of these options, restart both frontend and backend servers:\n")
    print("   cd /Users/kuoldeng/projectx/backend/pyfactor")
    print("   python run_server.py")
    print("   cd /Users/kuoldeng/projectx")
    print("   pnpm run dev:https\n")
    
    print("="*80)
    print("Note: Once the certificate is trusted, the CORS fix we implemented will work correctly.")
    print("="*80 + "\n")

def main():
    """Main function to execute the SSL certificate fix"""
    logger.info("Starting SSL certificate verification script")
    
    # Get project root directory
    script_dir = os.path.dirname(os.path.abspath(__file__))
    os.chdir(os.path.dirname(script_dir))  # Change to pyfactor directory
    
    success = True
    
    # Check if certificates exist
    if not check_certificates_exist():
        logger.error("Certificate files missing. Please create them first.")
        print_browser_instructions()
        success = False
    else:
        # Check certificate validity
        if not check_certificate_validity():
            logger.error("Certificate validation failed. Please check the certificates.")
            print_browser_instructions()
            success = False
        else:
            logger.info("SSL certificates are valid!")
            print_browser_instructions()
    
    # Update script registry
    update_script_registry(success)
    
    if success:
        logger.info("SSL certificate verification completed successfully.")
        return True
    else:
        logger.info("SSL certificate verification completed with issues to address.")
        return False

if __name__ == "__main__":
    sys.exit(0 if main() else 1) 