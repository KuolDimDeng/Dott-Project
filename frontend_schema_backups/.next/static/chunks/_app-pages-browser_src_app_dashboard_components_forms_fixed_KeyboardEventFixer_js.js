"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_src_app_dashboard_components_forms_fixed_KeyboardEventFixer_js"],{

/***/ "(app-pages-browser)/./src/app/dashboard/components/forms/fixed/KeyboardEventFixer.js":
/*!************************************************************************!*\
  !*** ./src/app/dashboard/components/forms/fixed/KeyboardEventFixer.js ***!
  \************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ KeyboardEventFixer)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../../node_modules/.pnpm/next@15.2.2_@babel+core@7.26.10_react-dom@18.3.1_react@18.3.1/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* __next_internal_client_entry_do_not_use__ default auto */ var _s = $RefreshSig$();\n\n/**\n * Optimized KeyboardEventFixer that reduces browser performance impact\n * while still fixing keyboard input issues\n */ function KeyboardEventFixer() {\n    _s();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"KeyboardEventFixer.useEffect\": ()=>{\n            console.log('KeyboardEventFixer mounted');\n            // Throttling mechanism\n            let lastFixTime = 0;\n            const THROTTLE_MS = 100; // Only run fixes every 100ms at most\n            // Track focused input element\n            let focusedInput = null;\n            let isFixActive = true;\n            // Create a toggle function that can be used for debugging\n            window.toggleInputFix = ({\n                \"KeyboardEventFixer.useEffect\": (enabled)=>{\n                    isFixActive = enabled !== undefined ? enabled : !isFixActive;\n                    console.log(\"Input fix is now \".concat(isFixActive ? 'enabled' : 'disabled'));\n                    document.body.setAttribute('data-keyboard-fixer', isFixActive ? 'active' : 'disabled');\n                    return isFixActive;\n                }\n            })[\"KeyboardEventFixer.useEffect\"];\n            // Track the focused element - this is more efficient than overriding addEventListener\n            const focusHandler = {\n                \"KeyboardEventFixer.useEffect.focusHandler\": (e)=>{\n                    var _e_target_tagName;\n                    const tagName = (_e_target_tagName = e.target.tagName) === null || _e_target_tagName === void 0 ? void 0 : _e_target_tagName.toLowerCase();\n                    if (tagName === 'input' || tagName === 'textarea' || tagName === 'select' || e.target.contentEditable === 'true' || e.target.role === 'textbox') {\n                        focusedInput = e.target;\n                    }\n                }\n            }[\"KeyboardEventFixer.useEffect.focusHandler\"];\n            const blurHandler = {\n                \"KeyboardEventFixer.useEffect.blurHandler\": ()=>{\n                    focusedInput = null;\n                }\n            }[\"KeyboardEventFixer.useEffect.blurHandler\"];\n            // Listen for focus/blur events\n            document.addEventListener('focusin', focusHandler);\n            document.addEventListener('focusout', blurHandler);\n            // Create an optimized keydown handler\n            const documentKeyHandler = {\n                \"KeyboardEventFixer.useEffect.documentKeyHandler\": (e)=>{\n                    // Skip processing if fix is disabled or no input is focused\n                    if (!isFixActive || !focusedInput || e.__redirected) return;\n                    // Check if focusedInput is still in the DOM\n                    if (!document.contains(focusedInput)) {\n                        focusedInput = null;\n                        return;\n                    }\n                    // Throttle processing to avoid performance issues\n                    const now = Date.now();\n                    if (now - lastFixTime < THROTTLE_MS) return;\n                    lastFixTime = now;\n                    // Only handle basic text input keys\n                    if (e.key.length === 1 || e.key === 'Backspace' || e.key === 'Delete' || e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.key === 'ArrowUp' || e.key === 'ArrowDown' || e.key === 'Home' || e.key === 'End' || e.key === 'Tab' || e.key === 'Enter' || e.key === 'Escape') {\n                        // Only for text inputs, use direct value manipulation for better performance\n                        if (e.key.length === 1 && (focusedInput.tagName.toLowerCase() === 'input' || focusedInput.tagName.toLowerCase() === 'textarea')) {\n                            try {\n                                // Safety check before manipulating the input\n                                if (!focusedInput || !focusedInput.isConnected) {\n                                    focusedInput = null;\n                                    return;\n                                }\n                                const start = focusedInput.selectionStart || 0;\n                                const end = focusedInput.selectionEnd || 0;\n                                const value = focusedInput.value || '';\n                                // Simulate typing by manually updating the input value\n                                const newValue = value.substring(0, start) + e.key + value.substring(end);\n                                focusedInput.value = newValue;\n                                // Set cursor position\n                                if (focusedInput && focusedInput.isConnected) {\n                                    focusedInput.selectionStart = start + 1;\n                                    focusedInput.selectionEnd = start + 1;\n                                }\n                                // Trigger change event - use InputEvent when possible for better React compatibility\n                                if (focusedInput && focusedInput.isConnected) {\n                                    if (typeof InputEvent === 'function') {\n                                        const inputEvent = new InputEvent('input', {\n                                            bubbles: true\n                                        });\n                                        focusedInput.dispatchEvent(inputEvent);\n                                    } else {\n                                        const changeEvent = new Event('input', {\n                                            bubbles: true\n                                        });\n                                        focusedInput.dispatchEvent(changeEvent);\n                                    }\n                                }\n                            } catch (error) {\n                                console.warn('KeyboardEventFixer: Error setting input properties', error);\n                                // The input is no longer usable, clear our reference\n                                focusedInput = null;\n                            }\n                            // Prevent the original event\n                            e.preventDefault();\n                            e.stopPropagation();\n                        }\n                    }\n                }\n            }[\"KeyboardEventFixer.useEffect.documentKeyHandler\"];\n            // Listen for keydown but only in capture phase to ensure we can fix keyboard events\n            document.addEventListener('keydown', documentKeyHandler, true);\n            // Create style element for fixed inputs, but more targeted\n            const style = document.createElement('style');\n            style.textContent = '\\n      /* Better input visibility */\\n      input:focus, textarea:focus, select:focus {\\n        z-index: 2000 !important;\\n        position: relative !important;\\n        pointer-events: auto !important;\\n        outline: 2px solid #4285f4 !important;\\n      }\\n      \\n      /* Make Drawer backdrop better behaved */\\n      .MuiBackdrop-root {\\n        pointer-events: none !important;\\n      }\\n      \\n      /* Add visual indicator that the fix is running */\\n      body[data-keyboard-fixer=\"active\"] .emergency-form input:focus,\\n      body[data-keyboard-fixer=\"active\"] .emergency-form textarea:focus {\\n        outline: 2px solid #4CAF50 !important;\\n        outline-offset: 2px !important;\\n      }\\n    ';\n            document.head.appendChild(style);\n            // Mark the body to indicate fix is active\n            document.body.setAttribute('data-keyboard-fixer', 'active');\n            return ({\n                \"KeyboardEventFixer.useEffect\": ()=>{\n                    // Clean up\n                    document.removeEventListener('focusin', focusHandler);\n                    document.removeEventListener('focusout', blurHandler);\n                    document.removeEventListener('keydown', documentKeyHandler, true);\n                    // Remove style\n                    if (style.parentNode) {\n                        style.parentNode.removeChild(style);\n                    }\n                    // Remove DOM attribute\n                    document.body.removeAttribute('data-keyboard-fixer');\n                    // Remove global toggle\n                    delete window.toggleInputFix;\n                }\n            })[\"KeyboardEventFixer.useEffect\"];\n        }\n    }[\"KeyboardEventFixer.useEffect\"], []);\n    // This component doesn't render anything\n    return null;\n}\n_s(KeyboardEventFixer, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n_c = KeyboardEventFixer;\nvar _c;\n$RefreshReg$(_c, \"KeyboardEventFixer\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvZGFzaGJvYXJkL2NvbXBvbmVudHMvZm9ybXMvZml4ZWQvS2V5Ym9hcmRFdmVudEZpeGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFFeUM7QUFFekM7OztDQUdDLEdBQ2MsU0FBU0U7O0lBQ3RCRCxnREFBU0E7d0NBQUM7WUFDUkUsUUFBUUMsR0FBRyxDQUFDO1lBRVosdUJBQXVCO1lBQ3ZCLElBQUlDLGNBQWM7WUFDbEIsTUFBTUMsY0FBYyxLQUFLLHFDQUFxQztZQUU5RCw4QkFBOEI7WUFDOUIsSUFBSUMsZUFBZTtZQUNuQixJQUFJQyxjQUFjO1lBRWxCLDBEQUEwRDtZQUMxREMsT0FBT0MsY0FBYztnREFBRyxDQUFDQztvQkFDdkJILGNBQWNHLFlBQVlDLFlBQVlELFVBQVUsQ0FBQ0g7b0JBQ2pETCxRQUFRQyxHQUFHLENBQUMsb0JBQXlELE9BQXJDSSxjQUFjLFlBQVk7b0JBQzFESyxTQUFTQyxJQUFJLENBQUNDLFlBQVksQ0FBQyx1QkFBdUJQLGNBQWMsV0FBVztvQkFDM0UsT0FBT0E7Z0JBQ1Q7O1lBRUEsc0ZBQXNGO1lBQ3RGLE1BQU1ROzZEQUFlLENBQUNDO3dCQUNKQTtvQkFBaEIsTUFBTUMsV0FBVUQsb0JBQUFBLEVBQUVFLE1BQU0sQ0FBQ0QsT0FBTyxjQUFoQkQsd0NBQUFBLGtCQUFrQkcsV0FBVztvQkFDN0MsSUFBSUYsWUFBWSxXQUFXQSxZQUFZLGNBQWNBLFlBQVksWUFDN0RELEVBQUVFLE1BQU0sQ0FBQ0UsZUFBZSxLQUFLLFVBQVVKLEVBQUVFLE1BQU0sQ0FBQ0csSUFBSSxLQUFLLFdBQVc7d0JBQ3RFZixlQUFlVSxFQUFFRSxNQUFNO29CQUN6QjtnQkFDRjs7WUFFQSxNQUFNSTs0REFBYztvQkFDbEJoQixlQUFlO2dCQUNqQjs7WUFFQSwrQkFBK0I7WUFDL0JNLFNBQVNXLGdCQUFnQixDQUFDLFdBQVdSO1lBQ3JDSCxTQUFTVyxnQkFBZ0IsQ0FBQyxZQUFZRDtZQUV0QyxzQ0FBc0M7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dUJBQXVCO1lBRWxEO2dEQUFPO29CQUNMLFdBQVc7b0JBQ1hGLFNBQVMwQyxtQkFBbUIsQ0FBQyxXQUFXdkM7b0JBQ3hDSCxTQUFTMEMsbUJBQW1CLENBQUMsWUFBWWhDO29CQUN6Q1YsU0FBUzBDLG1CQUFtQixDQUFDLFdBQVc5QixvQkFBb0I7b0JBRTVELGVBQWU7b0JBQ2YsSUFBSXlCLE1BQU1NLFVBQVUsRUFBRTt3QkFDcEJOLE1BQU1NLFVBQVUsQ0FBQ0MsV0FBVyxDQUFDUDtvQkFDL0I7b0JBRUEsdUJBQXVCO29CQUN2QnJDLFNBQVNDLElBQUksQ0FBQzRDLGVBQWUsQ0FBQztvQkFFOUIsdUJBQXVCO29CQUN2QixPQUFPakQsT0FBT0MsY0FBYztnQkFDOUI7O1FBQ0Y7dUNBQUcsRUFBRTtJQUVMLHlDQUF5QztJQUN6QyxPQUFPO0FBQ1Q7R0FsS3dCUjtLQUFBQSIsInNvdXJjZXMiOlsiL1VzZXJzL2t1b2xkZW5nL3Byb2plY3R4L2Zyb250ZW5kL3B5ZmFjdG9yX25leHQvc3JjL2FwcC9kYXNoYm9hcmQvY29tcG9uZW50cy9mb3Jtcy9maXhlZC9LZXlib2FyZEV2ZW50Rml4ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIE9wdGltaXplZCBLZXlib2FyZEV2ZW50Rml4ZXIgdGhhdCByZWR1Y2VzIGJyb3dzZXIgcGVyZm9ybWFuY2UgaW1wYWN0XG4gKiB3aGlsZSBzdGlsbCBmaXhpbmcga2V5Ym9hcmQgaW5wdXQgaXNzdWVzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEtleWJvYXJkRXZlbnRGaXhlcigpIHtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zb2xlLmxvZygnS2V5Ym9hcmRFdmVudEZpeGVyIG1vdW50ZWQnKTtcbiAgICBcbiAgICAvLyBUaHJvdHRsaW5nIG1lY2hhbmlzbVxuICAgIGxldCBsYXN0Rml4VGltZSA9IDA7XG4gICAgY29uc3QgVEhST1RUTEVfTVMgPSAxMDA7IC8vIE9ubHkgcnVuIGZpeGVzIGV2ZXJ5IDEwMG1zIGF0IG1vc3RcbiAgICBcbiAgICAvLyBUcmFjayBmb2N1c2VkIGlucHV0IGVsZW1lbnRcbiAgICBsZXQgZm9jdXNlZElucHV0ID0gbnVsbDtcbiAgICBsZXQgaXNGaXhBY3RpdmUgPSB0cnVlO1xuICAgIFxuICAgIC8vIENyZWF0ZSBhIHRvZ2dsZSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIGZvciBkZWJ1Z2dpbmdcbiAgICB3aW5kb3cudG9nZ2xlSW5wdXRGaXggPSAoZW5hYmxlZCkgPT4ge1xuICAgICAgaXNGaXhBY3RpdmUgPSBlbmFibGVkICE9PSB1bmRlZmluZWQgPyBlbmFibGVkIDogIWlzRml4QWN0aXZlO1xuICAgICAgY29uc29sZS5sb2coYElucHV0IGZpeCBpcyBub3cgJHtpc0ZpeEFjdGl2ZSA/ICdlbmFibGVkJyA6ICdkaXNhYmxlZCd9YCk7XG4gICAgICBkb2N1bWVudC5ib2R5LnNldEF0dHJpYnV0ZSgnZGF0YS1rZXlib2FyZC1maXhlcicsIGlzRml4QWN0aXZlID8gJ2FjdGl2ZScgOiAnZGlzYWJsZWQnKTtcbiAgICAgIHJldHVybiBpc0ZpeEFjdGl2ZTtcbiAgICB9O1xuICAgIFxuICAgIC8vIFRyYWNrIHRoZSBmb2N1c2VkIGVsZW1lbnQgLSB0aGlzIGlzIG1vcmUgZWZmaWNpZW50IHRoYW4gb3ZlcnJpZGluZyBhZGRFdmVudExpc3RlbmVyXG4gICAgY29uc3QgZm9jdXNIYW5kbGVyID0gKGUpID0+IHtcbiAgICAgIGNvbnN0IHRhZ05hbWUgPSBlLnRhcmdldC50YWdOYW1lPy50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKHRhZ05hbWUgPT09ICdpbnB1dCcgfHwgdGFnTmFtZSA9PT0gJ3RleHRhcmVhJyB8fCB0YWdOYW1lID09PSAnc2VsZWN0JyB8fCBcbiAgICAgICAgICBlLnRhcmdldC5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJyB8fCBlLnRhcmdldC5yb2xlID09PSAndGV4dGJveCcpIHtcbiAgICAgICAgZm9jdXNlZElucHV0ID0gZS50YXJnZXQ7XG4gICAgICB9XG4gICAgfTtcbiAgICBcbiAgICBjb25zdCBibHVySGFuZGxlciA9ICgpID0+IHtcbiAgICAgIGZvY3VzZWRJbnB1dCA9IG51bGw7XG4gICAgfTtcbiAgICBcbiAgICAvLyBMaXN0ZW4gZm9yIGZvY3VzL2JsdXIgZXZlbnRzXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIGZvY3VzSGFuZGxlcik7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCBibHVySGFuZGxlcik7XG4gICAgXG4gICAgLy8gQ3JlYXRlIGFuIG9wdGltaXplZCBrZXlkb3duIGhhbmRsZXJcbiAgICBjb25zdCBkb2N1bWVudEtleUhhbmRsZXIgPSAoZSkgPT4ge1xuICAgICAgLy8gU2tpcCBwcm9jZXNzaW5nIGlmIGZpeCBpcyBkaXNhYmxlZCBvciBubyBpbnB1dCBpcyBmb2N1c2VkXG4gICAgICBpZiAoIWlzRml4QWN0aXZlIHx8ICFmb2N1c2VkSW5wdXQgfHwgZS5fX3JlZGlyZWN0ZWQpIHJldHVybjtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgZm9jdXNlZElucHV0IGlzIHN0aWxsIGluIHRoZSBET01cbiAgICAgIGlmICghZG9jdW1lbnQuY29udGFpbnMoZm9jdXNlZElucHV0KSkge1xuICAgICAgICBmb2N1c2VkSW5wdXQgPSBudWxsO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFRocm90dGxlIHByb2Nlc3NpbmcgdG8gYXZvaWQgcGVyZm9ybWFuY2UgaXNzdWVzXG4gICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgaWYgKG5vdyAtIGxhc3RGaXhUaW1lIDwgVEhST1RUTEVfTVMpIHJldHVybjtcbiAgICAgIGxhc3RGaXhUaW1lID0gbm93O1xuICAgICAgXG4gICAgICAvLyBPbmx5IGhhbmRsZSBiYXNpYyB0ZXh0IGlucHV0IGtleXNcbiAgICAgIGlmIChlLmtleS5sZW5ndGggPT09IDEgfHwgZS5rZXkgPT09ICdCYWNrc3BhY2UnIHx8IGUua2V5ID09PSAnRGVsZXRlJyB8fCBcbiAgICAgICAgICBlLmtleSA9PT0gJ0Fycm93TGVmdCcgfHwgZS5rZXkgPT09ICdBcnJvd1JpZ2h0JyB8fCBcbiAgICAgICAgICBlLmtleSA9PT0gJ0Fycm93VXAnIHx8IGUua2V5ID09PSAnQXJyb3dEb3duJyB8fCBcbiAgICAgICAgICBlLmtleSA9PT0gJ0hvbWUnIHx8IGUua2V5ID09PSAnRW5kJyB8fCBcbiAgICAgICAgICBlLmtleSA9PT0gJ1RhYicgfHwgZS5rZXkgPT09ICdFbnRlcicgfHwgXG4gICAgICAgICAgZS5rZXkgPT09ICdFc2NhcGUnKSB7XG4gICAgICAgIFxuICAgICAgICAvLyBPbmx5IGZvciB0ZXh0IGlucHV0cywgdXNlIGRpcmVjdCB2YWx1ZSBtYW5pcHVsYXRpb24gZm9yIGJldHRlciBwZXJmb3JtYW5jZVxuICAgICAgICBpZiAoZS5rZXkubGVuZ3RoID09PSAxICYmIFxuICAgICAgICAgICAgKGZvY3VzZWRJbnB1dC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcgfHwgXG4gICAgICAgICAgICAgZm9jdXNlZElucHV0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3RleHRhcmVhJykpIHtcbiAgICAgICAgICBcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gU2FmZXR5IGNoZWNrIGJlZm9yZSBtYW5pcHVsYXRpbmcgdGhlIGlucHV0XG4gICAgICAgICAgICBpZiAoIWZvY3VzZWRJbnB1dCB8fCAhZm9jdXNlZElucHV0LmlzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgIGZvY3VzZWRJbnB1dCA9IG51bGw7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBmb2N1c2VkSW5wdXQuc2VsZWN0aW9uU3RhcnQgfHwgMDtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IGZvY3VzZWRJbnB1dC5zZWxlY3Rpb25FbmQgfHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZm9jdXNlZElucHV0LnZhbHVlIHx8ICcnO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBTaW11bGF0ZSB0eXBpbmcgYnkgbWFudWFsbHkgdXBkYXRpbmcgdGhlIGlucHV0IHZhbHVlXG4gICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHZhbHVlLnN1YnN0cmluZygwLCBzdGFydCkgKyBlLmtleSArIHZhbHVlLnN1YnN0cmluZyhlbmQpO1xuICAgICAgICAgICAgZm9jdXNlZElucHV0LnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFNldCBjdXJzb3IgcG9zaXRpb25cbiAgICAgICAgICAgIGlmIChmb2N1c2VkSW5wdXQgJiYgZm9jdXNlZElucHV0LmlzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgIGZvY3VzZWRJbnB1dC5zZWxlY3Rpb25TdGFydCA9IHN0YXJ0ICsgMTtcbiAgICAgICAgICAgICAgZm9jdXNlZElucHV0LnNlbGVjdGlvbkVuZCA9IHN0YXJ0ICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gVHJpZ2dlciBjaGFuZ2UgZXZlbnQgLSB1c2UgSW5wdXRFdmVudCB3aGVuIHBvc3NpYmxlIGZvciBiZXR0ZXIgUmVhY3QgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgaWYgKGZvY3VzZWRJbnB1dCAmJiBmb2N1c2VkSW5wdXQuaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBJbnB1dEV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5wdXRFdmVudCA9IG5ldyBJbnB1dEV2ZW50KCdpbnB1dCcsIHsgYnViYmxlczogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICBmb2N1c2VkSW5wdXQuZGlzcGF0Y2hFdmVudChpbnB1dEV2ZW50KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFuZ2VFdmVudCA9IG5ldyBFdmVudCgnaW5wdXQnLCB7IGJ1YmJsZXM6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgZm9jdXNlZElucHV0LmRpc3BhdGNoRXZlbnQoY2hhbmdlRXZlbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignS2V5Ym9hcmRFdmVudEZpeGVyOiBFcnJvciBzZXR0aW5nIGlucHV0IHByb3BlcnRpZXMnLCBlcnJvcik7XG4gICAgICAgICAgICAvLyBUaGUgaW5wdXQgaXMgbm8gbG9uZ2VyIHVzYWJsZSwgY2xlYXIgb3VyIHJlZmVyZW5jZVxuICAgICAgICAgICAgZm9jdXNlZElucHV0ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUHJldmVudCB0aGUgb3JpZ2luYWwgZXZlbnRcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgLy8gTGlzdGVuIGZvciBrZXlkb3duIGJ1dCBvbmx5IGluIGNhcHR1cmUgcGhhc2UgdG8gZW5zdXJlIHdlIGNhbiBmaXgga2V5Ym9hcmQgZXZlbnRzXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGRvY3VtZW50S2V5SGFuZGxlciwgdHJ1ZSk7XG4gICAgXG4gICAgLy8gQ3JlYXRlIHN0eWxlIGVsZW1lbnQgZm9yIGZpeGVkIGlucHV0cywgYnV0IG1vcmUgdGFyZ2V0ZWRcbiAgICBjb25zdCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgc3R5bGUudGV4dENvbnRlbnQgPSBgXG4gICAgICAvKiBCZXR0ZXIgaW5wdXQgdmlzaWJpbGl0eSAqL1xuICAgICAgaW5wdXQ6Zm9jdXMsIHRleHRhcmVhOmZvY3VzLCBzZWxlY3Q6Zm9jdXMge1xuICAgICAgICB6LWluZGV4OiAyMDAwICFpbXBvcnRhbnQ7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZSAhaW1wb3J0YW50O1xuICAgICAgICBwb2ludGVyLWV2ZW50czogYXV0byAhaW1wb3J0YW50O1xuICAgICAgICBvdXRsaW5lOiAycHggc29saWQgIzQyODVmNCAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiBNYWtlIERyYXdlciBiYWNrZHJvcCBiZXR0ZXIgYmVoYXZlZCAqL1xuICAgICAgLk11aUJhY2tkcm9wLXJvb3Qge1xuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZSAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiBBZGQgdmlzdWFsIGluZGljYXRvciB0aGF0IHRoZSBmaXggaXMgcnVubmluZyAqL1xuICAgICAgYm9keVtkYXRhLWtleWJvYXJkLWZpeGVyPVwiYWN0aXZlXCJdIC5lbWVyZ2VuY3ktZm9ybSBpbnB1dDpmb2N1cyxcbiAgICAgIGJvZHlbZGF0YS1rZXlib2FyZC1maXhlcj1cImFjdGl2ZVwiXSAuZW1lcmdlbmN5LWZvcm0gdGV4dGFyZWE6Zm9jdXMge1xuICAgICAgICBvdXRsaW5lOiAycHggc29saWQgIzRDQUY1MCAhaW1wb3J0YW50O1xuICAgICAgICBvdXRsaW5lLW9mZnNldDogMnB4ICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgYDtcbiAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICBcbiAgICAvLyBNYXJrIHRoZSBib2R5IHRvIGluZGljYXRlIGZpeCBpcyBhY3RpdmVcbiAgICBkb2N1bWVudC5ib2R5LnNldEF0dHJpYnV0ZSgnZGF0YS1rZXlib2FyZC1maXhlcicsICdhY3RpdmUnKTtcbiAgICBcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgLy8gQ2xlYW4gdXBcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCBmb2N1c0hhbmRsZXIpO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCBibHVySGFuZGxlcik7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZG9jdW1lbnRLZXlIYW5kbGVyLCB0cnVlKTtcbiAgICAgIFxuICAgICAgLy8gUmVtb3ZlIHN0eWxlXG4gICAgICBpZiAoc3R5bGUucGFyZW50Tm9kZSkge1xuICAgICAgICBzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gUmVtb3ZlIERPTSBhdHRyaWJ1dGVcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWtleWJvYXJkLWZpeGVyJyk7XG4gICAgICBcbiAgICAgIC8vIFJlbW92ZSBnbG9iYWwgdG9nZ2xlXG4gICAgICBkZWxldGUgd2luZG93LnRvZ2dsZUlucHV0Rml4O1xuICAgIH07XG4gIH0sIFtdKTtcbiAgXG4gIC8vIFRoaXMgY29tcG9uZW50IGRvZXNuJ3QgcmVuZGVyIGFueXRoaW5nXG4gIHJldHVybiBudWxsO1xufSJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZUVmZmVjdCIsIktleWJvYXJkRXZlbnRGaXhlciIsImNvbnNvbGUiLCJsb2ciLCJsYXN0Rml4VGltZSIsIlRIUk9UVExFX01TIiwiZm9jdXNlZElucHV0IiwiaXNGaXhBY3RpdmUiLCJ3aW5kb3ciLCJ0b2dnbGVJbnB1dEZpeCIsImVuYWJsZWQiLCJ1bmRlZmluZWQiLCJkb2N1bWVudCIsImJvZHkiLCJzZXRBdHRyaWJ1dGUiLCJmb2N1c0hhbmRsZXIiLCJlIiwidGFnTmFtZSIsInRhcmdldCIsInRvTG93ZXJDYXNlIiwiY29udGVudEVkaXRhYmxlIiwicm9sZSIsImJsdXJIYW5kbGVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsImRvY3VtZW50S2V5SGFuZGxlciIsIl9fcmVkaXJlY3RlZCIsImNvbnRhaW5zIiwibm93IiwiRGF0ZSIsImtleSIsImxlbmd0aCIsImlzQ29ubmVjdGVkIiwic3RhcnQiLCJzZWxlY3Rpb25TdGFydCIsImVuZCIsInNlbGVjdGlvbkVuZCIsInZhbHVlIiwibmV3VmFsdWUiLCJzdWJzdHJpbmciLCJJbnB1dEV2ZW50IiwiaW5wdXRFdmVudCIsImJ1YmJsZXMiLCJkaXNwYXRjaEV2ZW50IiwiY2hhbmdlRXZlbnQiLCJFdmVudCIsImVycm9yIiwid2FybiIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwic3R5bGUiLCJjcmVhdGVFbGVtZW50IiwidGV4dENvbnRlbnQiLCJoZWFkIiwiYXBwZW5kQ2hpbGQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwicmVtb3ZlQXR0cmlidXRlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/dashboard/components/forms/fixed/KeyboardEventFixer.js\n"));

/***/ })

}]);