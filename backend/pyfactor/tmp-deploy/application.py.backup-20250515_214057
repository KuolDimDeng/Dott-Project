import os
import sys
import traceback
import logging

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(levelname)s %(asctime)s %(module)s %(message)s',
    handlers=[logging.StreamHandler()]
)
logger = logging.getLogger(__name__)

# Add the project directory to the Python path
path = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
if path not in sys.path:
    sys.path.append(path)

# Set the Django settings module - default to settings_eb.py for Elastic Beanstalk
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'pyfactor.settings_eb')

# Determine if we're running in the Elastic Beanstalk environment
IN_ELASTIC_BEANSTALK = 'EB_ENV_NAME' in os.environ

# Health check WSGI application
def application(environ, start_response):
    path = environ.get('PATH_INFO', '')
    
    # Handle health check endpoint
    if path == '/health/':
        logger.info("Health check request received")
        status = '200 OK'
        headers = [('Content-type', 'text/plain')]
        start_response(status, headers)
        return [b'Healthy']
    
    # For all other paths, try using Django
    try:
        logger.info(f"Processing request: {path}")
        from django.core.wsgi import get_wsgi_application
        django_app = get_wsgi_application()
        return django_app(environ, start_response)
    except Exception as e:
        # Log the full traceback for debugging
        logger.error(f"Error in Django application: {str(e)}")
        logger.error(traceback.format_exc())
        
        # Fallback response for any errors
        status = '500 Internal Server Error'
        headers = [('Content-type', 'text/plain')]
        
        # Only show detailed error in non-production environments
        if not IN_ELASTIC_BEANSTALK or os.environ.get('DEBUG', 'False').lower() == 'true':
            error_message = f"Application Error: {str(e)}

{traceback.format_exc()}"
            start_response(status, headers)
            return [error_message.encode('utf-8')]
        else:
            # In production, show a generic error message
            start_response(status, headers)
            return [b'Application Error. Please check the logs for details.']

if __name__ == '__main__':
    # For local testing
    from wsgiref.simple_server import make_server
    
    httpd = make_server('', 8000, application)
    print("Serving on port 8000...")
    httpd.serve_forever()
