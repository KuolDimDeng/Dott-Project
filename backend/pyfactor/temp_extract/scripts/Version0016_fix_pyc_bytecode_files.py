#!/usr/bin/env python3
"""
Version0016_fix_pyc_bytecode_files.py

This script fixes AWS Elastic Beanstalk deployment issues related to Python bytecode files:
1. More aggressively removes all .pyc files and __pycache__ directories before packaging
2. Enhances exclusion patterns to ensure bytecode files don't get included
3. Creates/updates .ebignore file to explicitly ignore problematic files
4. Adds additional cleanup steps in prebuild hooks

Usage:
    python backend/pyfactor/scripts/Version0016_fix_pyc_bytecode_files.py

Output:
    - Updates scripts and configuration files to fix bytecode file issues
    - Creates optimized-clean-package.zip ready for deployment
"""

import os
import sys
import re
import shutil
import zipfile
import tempfile
import subprocess
import datetime
from pathlib import Path
import fnmatch

# Configuration
PROJECT_ROOT = Path(os.path.abspath(os.path.dirname(os.path.dirname(__file__))))
SCRIPTS_DIR = PROJECT_ROOT / "scripts"
OUTPUT_ZIP = PROJECT_ROOT / "optimized-clean-package.zip"
TIMESTAMP = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")

# Create script registry entry
REGISTRY_ENTRY = {
    "scriptName": "Version0016_fix_pyc_bytecode_files.py",
    "version": "1.0",
    "dateCreated": datetime.datetime.now().strftime("%Y-%m-%d"),
    "purpose": "Fixes AWS Elastic Beanstalk deployment issues with Python bytecode files",
    "status": "active",
    "executionCount": 0
}

# Enhanced exclusion patterns specifically targeting bytecode and cache files
EXCLUDE_PATTERNS = [
    # Python bytecode and cache files
    "__pycache__/",
    "*.py[cod]",
    "*$py.class",
    "*.so",
    ".Python",
    
    # Virtual environments
    "env/",
    "venv/",
    ".env/",
    ".venv/",
    "ENV/",
    
    # Log files and databases
    "*.log",
    "*.sqlite3",
    "*.db",
    
    # Development files
    ".git/",
    ".vscode/",
    ".idea/",
    "*.swp",
    "*.swo",
    ".DS_Store",
    
    # Backup files
    "*~",
    "backups/",
    "*.bak",
    "*.backup",
    
    # Node.js specific
    "node_modules/",
    
    # Testing and documentation
    ".coverage",
    "htmlcov/",
    ".pytest_cache/",
    ".tox/",
    "docs/_build/",
    
    # Distribution / packaging
    "build/",
    "develop-eggs/",
    "dist/",
    "downloads/",
    "eggs/",
    ".eggs/",
    "lib/",
    "lib64/",
    "parts/",
    "sdist/",
    "var/",
    "wheels/",
    "*.egg-info/",
    ".installed.cfg",
    "*.egg",
]

# Updated content for .ebignore file
EB_IGNORE_CONTENT = """# AWS Elastic Beanstalk .ebignore file
# Generated by Version0016_fix_pyc_bytecode_files.py on {timestamp}

# Python bytecode and cache files
__pycache__/
*.py[cod]
*$py.class
*.so
.Python

# Virtual environments
env/
venv/
.env/
.venv/
ENV/

# Log files and databases
*.log
*.sqlite3
*.db

# Development files
.git/
.vscode/
.idea/
*.swp
*.swo
.DS_Store

# Backup files
*~
backups/
*.bak
*.backup

# Node.js specific
node_modules/

# Testing and documentation
.coverage
htmlcov/
.pytest_cache/
.tox/
docs/_build/

# Distribution / packaging
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
"""

# Updated prebuild script with enhanced bytecode cleanup
PREBUILD_SCRIPT = """#!/bin/bash
# Enhanced prebuild script updated by Version0016_fix_pyc_bytecode_files.py
# This script runs before building the application

set -e   # Exit on error
set -o pipefail # Exit if any command in a pipe fails
set -x   # Print commands for debugging
exec > >(tee -a /var/log/eb-prebuild.log) 2>&1  # Redirect output to log file

echo "==== ENHANCED PREBUILD STARTING AT $(date) ===="
echo "Script version: Updated by Version0016_fix_pyc_bytecode_files.py"

# Define paths
APP_DIR="/var/app/staging"
VENV_DIR="/var/app/venv/staging"

echo "==== ENVIRONMENT INFORMATION ===="
echo "Python version: $(python --version)"
echo "Platform: $(uname -a)"
echo "Working directory: $(pwd)"

# IMPORTANT: Aggressive cleanup of all bytecode files
echo "==== CLEANING UP BYTECODE FILES AND CACHES ===="
echo "Finding and removing all __pycache__ directories..."
find . -type d -name "__pycache__" -exec rm -rf {} +

echo "Finding and removing all .pyc files..."
find . -type f -name "*.pyc" -delete

echo "Finding and removing all .pyo files..."
find . -type f -name "*.pyo" -delete

echo "Finding and removing all .pyd files..."
find . -type f -name "*.pyd" -delete

echo "Directory contents after cleanup:"
ls -la

# Create a constraints file to enforce package versions
cat > /tmp/pip-constraints.txt << EOL
urllib3==1.26.16
boto3==1.26.164
botocore==1.29.164
s3transfer==0.6.2
EOL

echo "==== CONSTRAINTS FILE CREATED ===="
cat /tmp/pip-constraints.txt

# Verify correct directories
if [ ! -d "$APP_DIR" ]; then
    echo "ERROR: Application directory $APP_DIR does not exist"
    mkdir -p "$APP_DIR"
    echo "Created $APP_DIR directory"
fi

# First, upgrade pip itself with specific version
echo "==== UPGRADING PIP ===="
pip install --upgrade pip==23.3.1 setuptools==69.0.3

# Force uninstall problematic packages
echo "==== REMOVING ANY CONFLICTING PACKAGES ===="
pip uninstall -y urllib3 boto3 botocore s3transfer awscli textract boto || true

# Install urllib3 first with no-dependencies to avoid conflicts
echo "==== INSTALLING URLLIB3 ===="
pip install urllib3==1.26.16 --no-dependencies

# Install AWS SDK components at compatible versions
echo "==== INSTALLING AWS SDK COMPONENTS ===="
pip install boto3==1.26.164 botocore==1.29.164 s3transfer==0.6.2 --no-dependencies

# Install critical packages explicitly with their exact versions
echo "==== INSTALLING CRITICAL PACKAGES ===="
pip install Django==4.2.10 gunicorn==21.2.0 psycopg2-binary==2.9.9

# Finally, install the rest of the requirements with constraints
echo "==== INSTALLING REMAINING REQUIREMENTS ===="
if [ -f "requirements-eb.txt" ]; then
    echo "Using EB requirements file"
    pip install -r requirements-eb.txt --constraint /tmp/pip-constraints.txt || {
        echo "ERROR installing from requirements-eb.txt"
        echo "Trying with --no-dependencies flag"
        pip install -r requirements-eb.txt --no-dependencies
    }
elif [ -f "requirements.txt" ]; then
    echo "Using standard requirements file"
    pip install -r requirements.txt --constraint /tmp/pip-constraints.txt || {
        echo "ERROR installing from requirements.txt"
        echo "Trying with --no-dependencies flag"
        pip install -r requirements.txt --no-dependencies
    }
else
    echo "ERROR: No requirements file found"
    exit 1
fi

# Verify the installed versions
echo "==== VERIFYING INSTALLED VERSIONS ===="
pip list | grep -E 'urllib3|boto3|botocore|s3transfer'

# Install PostgreSQL libraries if needed (for non-binary psycopg2)
echo "==== ENSURING POSTGRESQL LIBRARIES ARE INSTALLED ===="
which yum > /dev/null && {
    # Detect Amazon Linux version
    if grep -q "Amazon Linux release 2023" /etc/os-release; then
        echo "Detected Amazon Linux 2023"
        
        # Enable PostgreSQL modules
        echo "Enabling PostgreSQL module"
        sudo dnf install -y dnf-plugins-core
        sudo dnf config-manager --set-enabled amazonlinux-appstream
        
        # First try the postgresql-devel package
        if ! sudo yum install -y postgresql-devel; then
            echo "Failed to install postgresql-devel, trying libpq-devel"
            # Try libpq-devel which is often a suitable replacement
            if ! sudo yum install -y libpq-devel; then
                echo "Failed to install libpq-devel, trying postgresql13-devel"
                # Try specific postgresql version packages
                for pg_version in 15 14 13 12 11; do
                    echo "Attempting to install postgresql${pg_version}-devel"
                    if sudo yum install -y postgresql${pg_version}-devel; then
                        echo "Successfully installed postgresql${pg_version}-devel"
                        break
                    fi
                done
            fi
        fi
    else
        echo "Detected Amazon Linux 2 or other - using postgresql-devel package"
        yum list installed | grep -qw postgresql-devel || sudo yum install -y postgresql-devel
    fi
}

# Clean pip cache to avoid conflicts with cached packages
pip cache purge

# FINAL BYTECODE CLEANUP: Run again to clean any bytecode that might have been generated
echo "==== FINAL BYTECODE CLEANUP ===="
find . -type d -name "__pycache__" -exec rm -rf {} + 2>/dev/null || true
find . -type f -name "*.pyc" -delete
find . -type f -name "*.pyo" -delete
find . -type f -name "*.pyd" -delete

echo "==== PREBUILD COMPLETED SUCCESSFULLY AT $(date) ===="
"""

def should_include_file(filepath, base_dir=None):
    """Determine if a file should be included in the deployment package with enhanced bytecode filtering"""
    if base_dir:
        relative_path = os.path.relpath(filepath, base_dir)
    else:
        relative_path = filepath
    
    # Check exclusion patterns first
    for pattern in EXCLUDE_PATTERNS:
        if fnmatch.fnmatch(relative_path, pattern):
            return False
        
        # Special handling for directory patterns
        if pattern.endswith('/'):
            pattern_dir = pattern[:-1]
            path_parts = relative_path.split(os.sep)
            if pattern_dir in path_parts:
                return False
    
    # Include all other files
    return True

def create_ebignore_file():
    """Create or update the .ebignore file to exclude problematic files"""
    print("Creating/updating .ebignore file...")
    
    ebignore_path = PROJECT_ROOT / ".ebignore"
    
    # Write the updated content
    with open(ebignore_path, "w") as f:
        f.write(EB_IGNORE_CONTENT.format(timestamp=TIMESTAMP))
    
    print(f"Updated .ebignore file at {ebignore_path}")
    return ebignore_path

def update_prebuild_script():
    """Update the prebuild script with enhanced bytecode cleanup"""
    print("Updating prebuild script with bytecode cleanup enhancements...")
    
    # Path to the original prebuild script
    prebuild_path = PROJECT_ROOT / ".platform" / "hooks" / "prebuild" / "01_install_dependencies.sh"
    
    # Ensure directory exists
    os.makedirs(os.path.dirname(prebuild_path), exist_ok=True)
    
    # Create backup of original
    if os.path.exists(prebuild_path):
        backup_file = f"{prebuild_path}.backup-{TIMESTAMP}"
        shutil.copy2(prebuild_path, backup_file)
        print(f"Created backup of original prebuild script: {backup_file}")
    
    # Write the updated content
    with open(prebuild_path, "w") as f:
        f.write(PREBUILD_SCRIPT)
    
    # Set execute permissions
    os.chmod(prebuild_path, 0o755)
    
    print(f"Updated prebuild script at {prebuild_path}")
    return prebuild_path

def clean_bytecode_files(directory):
    """Clean all bytecode and cache files from the given directory"""
    print(f"Cleaning bytecode files from {directory}...")
    
    # Remove __pycache__ directories
    pycache_dirs = []
    for root, dirs, files in os.walk(directory):
        for dirname in dirs:
            if dirname == "__pycache__":
                pycache_dirs.append(os.path.join(root, dirname))
                
    for pycache_dir in pycache_dirs:
        print(f"Removing __pycache__ directory: {pycache_dir}")
        try:
            shutil.rmtree(pycache_dir)
        except Exception as e:
            print(f"Warning: Could not remove {pycache_dir}: {e}")
    
    # Remove .pyc, .pyo, and .pyd files
    pyc_count = 0
    for root, dirs, files in os.walk(directory):
        for filename in files:
            if filename.endswith((".pyc", ".pyo", ".pyd")):
                filepath = os.path.join(root, filename)
                try:
                    os.remove(filepath)
                    pyc_count += 1
                except Exception as e:
                    print(f"Warning: Could not remove {filepath}: {e}")
    
    print(f"Removed {len(pycache_dirs)} __pycache__ directories and {pyc_count} bytecode files")

def create_deployment_package():
    """Create an optimized deployment package for Elastic Beanstalk with enhanced bytecode handling"""
    print(f"Creating optimized deployment package with bytecode file fixes...")
    
    # First clean bytecode files from the project directory
    clean_bytecode_files(PROJECT_ROOT)
    
    # Create a temporary directory for building the package
    with tempfile.TemporaryDirectory() as temp_dir:
        temp_path = Path(temp_dir)
        print(f"Using temporary directory: {temp_dir}")
        
        # Copy necessary files to the temp directory
        print("Copying application files (excluding bytecode)...")
        
        # Define files we specifically want to include
        include_files = [
            # Application core
            "application.py",
            "manage.py",
            "requirements-eb.txt",
            "requirements.txt",
            
            # Configuration directories
            ".ebextensions/",
            ".platform/",
            ".ebignore",
            
            # Application code
            "pyfactor/",
            "api/",
            "users/",
            "finance/",
            "hr/",
            "banking/",
            "onboarding/",
            "payroll/",
            "reports/",
            "data/",
        ]
        
        # Copy files, filtering out bytecode
        for root, dirs, files in os.walk(PROJECT_ROOT):
            # Skip excluded directories in-place (modifying dirs directly)
            dirs[:] = [d for d in dirs if not any(d == pattern.rstrip("/") for pattern in EXCLUDE_PATTERNS if pattern.endswith("/"))]
            
            for file in files:
                src_path = os.path.join(root, file)
                rel_path = os.path.relpath(src_path, PROJECT_ROOT)
                
                # Skip bytecode files
                if any(fnmatch.fnmatch(rel_path, pattern) for pattern in ["*.pyc", "*.pyo", "*.pyd", "*__pycache__*"]):
                    continue
                
                # Skip other excluded patterns
                if not should_include_file(rel_path):
                    continue
                
                # Only include files in our include list (or their parent directories)
                include_this_file = False
                for include in include_files:
                    if include.endswith("/"):
                        # It's a directory - check if this file is in that directory
                        if rel_path.startswith(include[:-1]):
                            include_this_file = True
                            break
                    elif include == rel_path:
                        # It matches exactly
                        include_this_file = True
                        break
                
                if include_this_file:
                    dst_path = os.path.join(temp_dir, rel_path)
                    os.makedirs(os.path.dirname(dst_path), exist_ok=True)
                    shutil.copy2(src_path, dst_path)
        
        # Double-check for bytecode files in the temp directory
        clean_bytecode_files(temp_path)
        
        # Make sure we have the latest .ebignore in the temp directory
        shutil.copy2(PROJECT_ROOT / ".ebignore", temp_path / ".ebignore")
        
        # Make sure we have enhanced hook scripts
        platform_dir = temp_path / ".platform"
        platform_hooks_prebuild = platform_dir / "hooks" / "prebuild"
        os.makedirs(platform_hooks_prebuild, exist_ok=True)
        
        # Write the enhanced prebuild script
        with open(platform_hooks_prebuild / "01_install_dependencies.sh", "w") as f:
            f.write(PREBUILD_SCRIPT)
        
        # Set execute permissions
        os.chmod(platform_hooks_prebuild / "01_install_dependencies.sh", 0o755)
        
        # Create the ZIP file
        print(f"Creating ZIP file: {OUTPUT_ZIP}")
        with zipfile.ZipFile(OUTPUT_ZIP, "w", zipfile.ZIP_DEFLATED) as zipf:
            for root, dirs, files in os.walk(temp_dir):
                # Skip __pycache__ directories and bytecode files
                dirs[:] = [d for d in dirs if d != "__pycache__"]
                
                for file in files:
                    if file.endswith((".pyc", ".pyo", ".pyd")):
                        continue
                        
                    file_path = os.path.join(root, file)
                    arcname = os.path.relpath(file_path, temp_dir)
                    print(f"Adding to ZIP: {arcname}")
                    zipf.write(file_path, arcname=arcname)
    
    print(f"Deployment package created successfully: {OUTPUT_ZIP}")
    print(f"Upload this ZIP file to AWS Elastic Beanstalk console for deployment.")
    return OUTPUT_ZIP

def update_script_registry():
    """Update the script registry with information about this script execution"""
    registry_file = SCRIPTS_DIR / "script_registry.js"
    
    if not os.path.exists(registry_file):
        # Create new registry file if it doesn't exist
        with open(registry_file, "w") as f:
            f.write("// Script Registry - Automatic Script Execution Tracking\n")
            f.write("export const scriptRegistry = [\n")
            f.write(f"  {{\n")
            f.write(f"    scriptName: '{REGISTRY_ENTRY['scriptName']}',\n")
            f.write(f"    version: '{REGISTRY_ENTRY['version']}',\n") 
            f.write(f"    dateCreated: '{REGISTRY_ENTRY['dateCreated']}',\n")
            f.write(f"    purpose: '{REGISTRY_ENTRY['purpose']}',\n")
            f.write(f"    status: '{REGISTRY_ENTRY['status']}',\n")
            f.write(f"    executionCount: 1,\n")
            f.write(f"    lastExecuted: '{datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}'\n")
            f.write("  }\n")
            f.write("];\n")
    else:
        # Update existing registry
        try:
            with open(registry_file, "r") as f:
                content = f.read()
            
            if REGISTRY_ENTRY['scriptName'] in content:
                # Script already in registry, update execution count
                print("Updating execution count in script registry...")
                # This is a simple string replacement, more robust solution would parse the JS
                import re
                pattern = fr"scriptName: '{REGISTRY_ENTRY['scriptName']}',[^}}]*executionCount: (\d+)"
                match = re.search(pattern, content, re.DOTALL)
                if match:
                    count = int(match.group(1)) + 1
                    new_entry = f"scriptName: '{REGISTRY_ENTRY['scriptName']}',\n    version: '{REGISTRY_ENTRY['version']}',\n    dateCreated: '{REGISTRY_ENTRY['dateCreated']}',\n    purpose: '{REGISTRY_ENTRY['purpose']}',\n    status: '{REGISTRY_ENTRY['status']}',\n    executionCount: {count},\n    lastExecuted: '{datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}'"
                    content = re.sub(pattern, new_entry, content, flags=re.DOTALL)
                    with open(registry_file, "w") as f:
                        f.write(content)
            else:
                # Add new entry
                print("Adding new entry to script registry...")
                import re
                pattern = r"export const scriptRegistry = \["
                new_entry = f"export const scriptRegistry = [\n  {{\n    scriptName: '{REGISTRY_ENTRY['scriptName']}',\n    version: '{REGISTRY_ENTRY['version']}',\n    dateCreated: '{REGISTRY_ENTRY['dateCreated']}',\n    purpose: '{REGISTRY_ENTRY['purpose']}',\n    status: '{REGISTRY_ENTRY['status']}',\n    executionCount: 1,\n    lastExecuted: '{datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}'\n  }},"
                content = re.sub(pattern, new_entry, content)
                with open(registry_file, "w") as f:
                    f.write(content)
                    
        except Exception as e:
            print(f"Warning: Could not update script registry: {e}")

def create_deployment_guide():
    """Create a document explaining the bytecode fixes"""
    guide_path = PROJECT_ROOT / "scripts" / "Bytecode_Files_Deployment_Fix.md"
    
    guide_content = f"""# Python Bytecode Files (.pyc) Deployment Fix

## Problem
When deploying to AWS Elastic Beanstalk, the deployment process was failing because of issues with Python bytecode files:

```
INFO:   -skipping: ./finance/migrations/__pycache__/0004_fix_multiple_dependencies.cpython-312.pyc
...
ERROR   [Instance: i-010b4b5741e3be406] Command failed on instance. Return code: 1 Output: Engine execution has encountered an error.
```

This occurs because:
1. Python automatically generates bytecode (.pyc) files when importing modules
2. These files are specific to the Python version used (e.g., cpython-312)
3. AWS Elastic Beanstalk deployment had issues with these files during the zip packaging process
4. The existing exclusion patterns weren't fully removing all bytecode files

## Solution
We implemented a comprehensive fix in the `Version0016_fix_pyc_bytecode_files.py` script:

1. **Enhanced Bytecode Cleanup:**
   - Aggressively removes ALL `__pycache__` directories and `.pyc`, `.pyo`, `.pyd` files
   - Includes multiple cleanup passes (before packaging and during prebuild)

2. **Improved Exclusion Patterns:**
   - Updated exclusion patterns using fnmatch for more reliable pattern matching
   - Added multiple bytecode file patterns to catch all variations

3. **Dedicated .ebignore File:**
   - Created/updated `.ebignore` file to explicitly tell Elastic Beanstalk which files to ignore
   - Includes comprehensive patterns for bytecode files

4. **Enhanced Prebuild Script:**
   - Added aggressive cleanup commands at the beginning of the prebuild process
   - Added final cleanup step to catch any bytecode files generated during the install process

## Technical Implementation

The script:

1. Recursively removes all `__pycache__` directories and `.pyc`, `.pyo`, `.pyd` files
2. Updates the `.platform/hooks/prebuild/01_install_dependencies.sh` script with bytecode cleanup commands
3. Creates/updates the `.ebignore` file with comprehensive exclusion patterns
4. Creates a clean deployment package avoiding bytecode files

## Deployment Instructions

1. The clean deployment package has been created at:
   ```
   {OUTPUT_ZIP}
   ```

2. Deploy using:
   ```bash
   cd {PROJECT_ROOT}
   ./scripts/deploy_fixed_env.sh
   ```
   
   Alternatively, manually upload the package through the AWS Elastic Beanstalk Console:
   - Choose "Upload and deploy"
   - Upload the {os.path.basename(OUTPUT_ZIP)} file
   - Make sure to select "Python 3.9 running on 64bit Amazon Linux 2023/4.5.1" platform

## Best Practices for Future Deployments

1. Always clean bytecode files before creating deployment packages:
   ```bash
   find . -type d -name "__pycache__" -exec rm -rf {{}} +
   find . -type f -name "*.pyc" -delete
   find . -type f -name "*.pyo" -delete
   find . -type f -name "*.pyd" -delete
   ```

2. Maintain the `.ebignore` file to exclude problematic files

3. Use the enhanced package creation script for all future deployments

## Related Scripts

- `Version0016_fix_pyc_bytecode_files.py` - Implements the bytecode file fix
- `Version0012_prepare_eb_package.py` - Original package creation script
- `deploy_fixed_env.sh` - Helper script for deployment

## Documentation

For more details about AWS Elastic Beanstalk deployment best practices, see:
- [AWS Documentation: Deploying Python Applications](https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/create-deploy-python-apps.html)
- [AWS Documentation: Using .ebignore](https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/eb3-deploy.html)
"""

    with open(guide_path, "w") as f:
        f.write(guide_content)
        
    print(f"Created deployment guide: {guide_path}")
    return guide_path

def create_deploy_script():
    """Create a script to deploy the fixed package"""
    script_path = PROJECT_ROOT / "scripts" / "deploy_fixed_bytecode.sh"
    
    script_content = f"""#!/bin/bash
# deploy_fixed_bytecode.sh
# Script to deploy the fixed package that addresses bytecode issues
# Created by Version0016_fix_pyc_bytecode_files.py

set -e  # Exit on error

SCRIPT_DIR="$(cd "$(dirname "${{BASH_SOURCE[0]}}")" && pwd)"
BACKEND_DIR="$(dirname "$SCRIPT_DIR")"
PACKAGE_ZIP="{os.path.basename(OUTPUT_ZIP)}"

echo "========================================================"
echo "   AWS ELASTIC BEANSTALK DEPLOYMENT - BYTECODE FIX"
echo "========================================================"
echo "This script will deploy the fixed package that addresses"
echo "Python bytecode file issues in Elastic Beanstalk."
echo "------------------------------------------------------"

# Check if application exists
cd "$BACKEND_DIR"
if [ ! -f "$PACKAGE_ZIP" ]; then
    echo "ERROR: Deployment package not found: $PACKAGE_ZIP"
    echo "Run the fix script first: python scripts/Version0016_fix_pyc_bytecode_files.py"
    exit 1
fi

# Check for EB CLI
if ! command -v eb &> /dev/null; then
    echo "AWS Elastic Beanstalk CLI (eb) not found."
    echo "Would you like to deploy through the AWS Console instead? (y/n)"
    read -r deploy_console
    
    if [[ "$deploy_console" == "y" ]]; then
        echo "------------------------------------------------------"
        echo "MANUAL DEPLOYMENT INSTRUCTIONS:"
        echo "1. Go to AWS Elastic Beanstalk Console"
        echo "2. Select your application and environment"
        echo "3. Click 'Upload and deploy'"
        echo "4. Upload this file: $BACKEND_DIR/$PACKAGE_ZIP"
        echo "5. Click 'Deploy'"
        echo "------------------------------------------------------"
        exit 0
    else
        echo "Please install the EB CLI and try again:"
        echo "pip install awsebcli"
        exit 1
    fi
fi

# Get environment name
echo "------------------------------------------------------"
echo "Available Elastic Beanstalk environments:"
eb list

echo "------------------------------------------------------"
echo "Enter the name of the environment to deploy to:"
read -r environment_name

# Deploy the application
echo "------------------------------------------------------"
echo "Deploying $PACKAGE_ZIP to environment: $environment_name"
echo "This may take several minutes..."
echo "------------------------------------------------------"

eb deploy "$environment_name" --staged

echo "------------------------------------------------------"
echo "Deployment complete! Check the AWS console for status."
echo "------------------------------------------------------"
"""

    with open(script_path, "w") as f:
        f.write(script_content)
    
    # Set execute permissions
    os.chmod(script_path, 0o755)
    
    print(f"Created deployment script: {script_path}")
    return script_path

def main():
    """Main execution function"""
    print("="*80)
    print("AWS Elastic Beanstalk Python Bytecode Fix")
    print("="*80)
    print(f"Created by: {REGISTRY_ENTRY['scriptName']} v{REGISTRY_ENTRY['version']}")
    print(f"Date: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print("="*80)
    
    try:
        # Step 1: Clean all bytecode files from the project
        print("\nStep 1: Cleaning bytecode files from the project...")
        clean_bytecode_files(PROJECT_ROOT)
        
        # Step 2: Create/update .ebignore file
        print("\nStep 2: Creating/updating .ebignore file...")
        ebignore_path = create_ebignore_file()
        
        # Step 3: Update prebuild script
        print("\nStep 3: Updating prebuild script...")
        prebuild_path = update_prebuild_script()
        
        # Step 4: Create deployment package
        print("\nStep 4: Creating clean deployment package...")
        zip_file = create_deployment_package()
        
        # Step 5: Create deployment guide
        print("\nStep 5: Creating documentation...")
        guide_path = create_deployment_guide()
        
        # Step 6: Create deployment script
        print("\nStep 6: Creating deployment script...")
        deploy_script = create_deploy_script()
        
        # Step 7: Update the script registry
        print("\nStep 7: Updating script registry...")
        update_script_registry()
        
        print("\nPYTHON BYTECODE FIX COMPLETED SUCCESSFULLY!")
        print("-" * 60)
        print(f"Package: {zip_file}")
        print(f"Size: {os.path.getsize(zip_file) / (1024*1024):.2f} MB")
        print(f"Deployment guide: {guide_path}")
        print(f"Deployment script: {deploy_script}")
        print("\nNext Steps:")
        print("1. Review the deployment guide: scripts/Bytecode_Files_Deployment_Fix.md")
        print("2. Deploy using: ./scripts/deploy_fixed_bytecode.sh")
        print("   OR")
        print("3. Log into AWS Elastic Beanstalk Console")
        print("4. Upload the optimized-clean-package.zip file when prompted")
        print("-" * 60)
        
    except Exception as e:
        print(f"ERROR: Failed to complete bytecode fix: {e}")
        import traceback
        traceback.print_exc()
        return 1
        
    return 0

if __name__ == "__main__":
    sys.exit(main())
