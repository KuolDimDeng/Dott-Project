# Generated by Django 5.1.7 on 2025-03-25 18:22

from django.db import migrations, connection, transaction


def forward_user_tenant_relations(apps, schema_editor):
    """Transfer FK relationships to UUID fields in custom_auth models"""
    db_alias = schema_editor.connection.alias
    connection = schema_editor.connection
    
    # Safely get the original model data with direct SQL
    print("Starting data migration for User-Tenant relationships")
    
    user_tenant_rows = []
    tenant_owner_rows = []
    
    # First check if backup tables exist to avoid transaction abort
    backup_exists = False
    with connection.cursor() as cursor:
        try:
            cursor.execute("""
                SELECT EXISTS (
                    SELECT FROM information_schema.tables 
                    WHERE table_schema = 'django_migrations_backup'
                    AND table_name = 'custom_auth_user'
                )
            """)
            backup_exists = cursor.fetchone()[0]
        except Exception:
            backup_exists = False
    
    # Only try to access backup tables if they exist
    if backup_exists:
        try:
            with connection.cursor() as cursor:
                # Retrieve old User-Tenant relationships
                cursor.execute("""
                    SELECT id, tenant_id 
                    FROM django_migrations_backup.custom_auth_user
                    WHERE tenant_id IS NOT NULL
                """)
                user_tenant_rows = cursor.fetchall()
                
                # Retrieve old Tenant-Owner relationships
                cursor.execute("""
                    SELECT id, owner_id 
                    FROM django_migrations_backup.custom_auth_tenant
                    WHERE owner_id IS NOT NULL
                """)
                tenant_owner_rows = cursor.fetchall()
        except Exception as e:
            print(f"Error accessing backup tables: {e}")
            # Reset these to empty in case of partial success
            user_tenant_rows = []
            tenant_owner_rows = []
    
    # If backup tables don't exist or error occurred, try fallback method
    if not user_tenant_rows and not tenant_owner_rows:
        try:
            print("Using fallback method to retrieve relationships...")
            
            # Use a new transaction for the fallback to avoid transaction abort issues
            with transaction.atomic(using=db_alias):
                with connection.cursor() as cursor:
                    # Check if users_userprofile table exists and has tenant_id
                    cursor.execute("""
                        SELECT EXISTS (
                            SELECT FROM information_schema.columns
                            WHERE table_name = 'users_userprofile'
                            AND column_name = 'tenant_id'
                        )
                    """)
                    has_userprofile_tenant = cursor.fetchone()[0]
                    
                    # Check if users_userprofile has is_business_owner field
                    cursor.execute("""
                        SELECT EXISTS (
                            SELECT FROM information_schema.columns
                            WHERE table_name = 'users_userprofile'
                            AND column_name = 'is_business_owner'
                        )
                    """)
                    has_business_owner = cursor.fetchone()[0]
                    
                    if has_userprofile_tenant:
                        # Get User-Tenant relationships from user profiles
                        cursor.execute("""
                            SELECT u.id, up.tenant_id
                            FROM custom_auth_user u
                            JOIN users_userprofile up ON u.id = up.user_id
                            WHERE up.tenant_id IS NOT NULL
                        """)
                        user_tenant_rows = cursor.fetchall()
                    
                    if has_userprofile_tenant and has_business_owner:
                        # Infer Tenant-Owner relationships
                        cursor.execute("""
                            SELECT t.id, u.id 
                            FROM custom_auth_tenant t
                            JOIN users_userprofile up ON t.id = up.tenant_id
                            JOIN custom_auth_user u ON up.user_id = u.id
                            WHERE up.is_business_owner = TRUE
                        """)
                        tenant_owner_rows = cursor.fetchall()
        except Exception as fallback_error:
            print(f"Fallback method failed: {fallback_error}")
            # Ensure we have empty lists rather than None
            user_tenant_rows = []
            tenant_owner_rows = []
    
    # Get the models from the apps registry
    User = apps.get_model('custom_auth', 'User')
    Tenant = apps.get_model('custom_auth', 'Tenant')
    
    # Use a transaction for the data update to ensure consistency
    with transaction.atomic(using=db_alias):
        # Update User.tenant_id
        print(f"Updating {len(user_tenant_rows)} user-tenant relationships")
        for user_id, tenant_id in user_tenant_rows:
            try:
                User.objects.using(db_alias).filter(id=user_id).update(tenant_id=tenant_id)
            except Exception as e:
                print(f"Error updating user {user_id} with tenant {tenant_id}: {e}")
        
        # Update Tenant.owner_id
        print(f"Updating {len(tenant_owner_rows)} tenant-owner relationships")
        for tenant_id, owner_id in tenant_owner_rows:
            try:
                Tenant.objects.using(db_alias).filter(id=tenant_id).update(owner_id=owner_id)
            except Exception as e:
                print(f"Error updating tenant {tenant_id} with owner {owner_id}: {e}")


def backward_user_tenant_relations(apps, schema_editor):
    """No reverse migration needed since ForeignKey fields are removed"""
    pass


class Migration(migrations.Migration):

    dependencies = [
        ('custom_auth', '0002_remove_tenant_owner_remove_user_tenant_and_more'),
    ]

    operations = [
        migrations.RunPython(forward_user_tenant_relations, backward_user_tenant_relations),
    ]
